{"ast":null,"code":"import \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport { copyTransform } from '../core/Transformable.js';\nimport { createBrushScope } from './core.js';\nimport SVGPathRebuilder from './SVGPathRebuilder.js';\nimport PathProxy from '../core/PathProxy.js';\nimport { getPathPrecision, getSRTTransformString } from './helper.js';\nimport { each, extend, filter, isNumber, isString, keys } from '../core/util.js';\nimport CompoundPath from '../graphic/CompoundPath.js';\nimport { createCubicEasingFunc } from '../animation/cubicEasing.js';\nexport var EASING_MAP = {\n  cubicIn: '0.32,0,0.67,0',\n  cubicOut: '0.33,1,0.68,1',\n  cubicInOut: '0.65,0,0.35,1',\n  quadraticIn: '0.11,0,0.5,0',\n  quadraticOut: '0.5,1,0.89,1',\n  quadraticInOut: '0.45,0,0.55,1',\n  quarticIn: '0.5,0,0.75,0',\n  quarticOut: '0.25,1,0.5,1',\n  quarticInOut: '0.76,0,0.24,1',\n  quinticIn: '0.64,0,0.78,0',\n  quinticOut: '0.22,1,0.36,1',\n  quinticInOut: '0.83,0,0.17,1',\n  sinusoidalIn: '0.12,0,0.39,0',\n  sinusoidalOut: '0.61,1,0.88,1',\n  sinusoidalInOut: '0.37,0,0.63,1',\n  exponentialIn: '0.7,0,0.84,0',\n  exponentialOut: '0.16,1,0.3,1',\n  exponentialInOut: '0.87,0,0.13,1',\n  circularIn: '0.55,0,1,0.45',\n  circularOut: '0,0.55,0.45,1',\n  circularInOut: '0.85,0,0.15,1'\n};\nvar transformOriginKey = 'transform-origin';\n\nfunction buildPathString(el, kfShape, path) {\n  var shape = extend({}, el.shape);\n  extend(shape, kfShape);\n  el.buildPath(path, shape);\n  var svgPathBuilder = new SVGPathRebuilder();\n  svgPathBuilder.reset(getPathPrecision(el));\n  path.rebuildPath(svgPathBuilder, 1);\n  svgPathBuilder.generateStr();\n  return svgPathBuilder.getStr();\n}\n\nfunction setTransformOrigin(target, transform) {\n  var originX = transform.originX,\n      originY = transform.originY;\n\n  if (originX || originY) {\n    target[transformOriginKey] = originX + \"px \" + originY + \"px\";\n  }\n}\n\nexport var ANIMATE_STYLE_MAP = {\n  fill: 'fill',\n  opacity: 'opacity',\n  lineWidth: 'stroke-width',\n  lineDashOffset: 'stroke-dashoffset'\n};\n\nfunction addAnimation(cssAnim, scope) {\n  var animationName = scope.zrId + '-ani-' + scope.cssAnimIdx++;\n  scope.cssAnims[animationName] = cssAnim;\n  return animationName;\n}\n\nfunction createCompoundPathCSSAnimation(el, attrs, scope) {\n  var paths = el.shape.paths;\n  var composedAnim = {};\n  var cssAnimationCfg;\n  var cssAnimationName;\n  each(paths, function (path) {\n    var subScope = createBrushScope(scope.zrId);\n    subScope.animation = true;\n    createCSSAnimation(path, {}, subScope, true);\n    var cssAnims = subScope.cssAnims;\n    var cssNodes = subScope.cssNodes;\n    var animNames = keys(cssAnims);\n    var len = animNames.length;\n\n    if (!len) {\n      return;\n    }\n\n    cssAnimationName = animNames[len - 1];\n    var lastAnim = cssAnims[cssAnimationName];\n\n    for (var percent in lastAnim) {\n      var kf = lastAnim[percent];\n      composedAnim[percent] = composedAnim[percent] || {\n        d: ''\n      };\n      composedAnim[percent].d += kf.d || '';\n    }\n\n    for (var className in cssNodes) {\n      var val = cssNodes[className].animation;\n\n      if (val.indexOf(cssAnimationName) >= 0) {\n        cssAnimationCfg = val;\n      }\n    }\n  });\n\n  if (!cssAnimationCfg) {\n    return;\n  }\n\n  attrs.d = false;\n  var animationName = addAnimation(composedAnim, scope);\n  return cssAnimationCfg.replace(cssAnimationName, animationName);\n}\n\nfunction getEasingFunc(easing) {\n  return isString(easing) ? EASING_MAP[easing] ? \"cubic-bezier(\" + EASING_MAP[easing] + \")\" : createCubicEasingFunc(easing) ? easing : '' : '';\n}\n\nexport function createCSSAnimation(el, attrs, scope, onlyShape) {\n  var animators = el.animators;\n  var len = animators.length;\n  var cssAnimations = [];\n\n  if (el instanceof CompoundPath) {\n    var animationCfg = createCompoundPathCSSAnimation(el, attrs, scope);\n\n    if (animationCfg) {\n      cssAnimations.push(animationCfg);\n    } else if (!len) {\n      return;\n    }\n  } else if (!len) {\n    return;\n  }\n\n  var groupAnimators = {};\n\n  for (var i = 0; i < len; i++) {\n    var animator = animators[i];\n    var cfgArr = [animator.getMaxTime() / 1000 + 's'];\n    var easing = getEasingFunc(animator.getClip().easing);\n    var delay = animator.getDelay();\n\n    if (easing) {\n      cfgArr.push(easing);\n    } else {\n      cfgArr.push('linear');\n    }\n\n    if (delay) {\n      cfgArr.push(delay / 1000 + 's');\n    }\n\n    if (animator.getLoop()) {\n      cfgArr.push('infinite');\n    }\n\n    var cfg = cfgArr.join(' ');\n    groupAnimators[cfg] = groupAnimators[cfg] || [cfg, []];\n    groupAnimators[cfg][1].push(animator);\n  }\n\n  function createSingleCSSAnimation(groupAnimator) {\n    var animators = groupAnimator[1];\n    var len = animators.length;\n    var transformKfs = {};\n    var shapeKfs = {};\n    var finalKfs = {};\n    var animationTimingFunctionAttrName = 'animation-timing-function';\n\n    function saveAnimatorTrackToCssKfs(animator, cssKfs, toCssAttrName) {\n      var tracks = animator.getTracks();\n      var maxTime = animator.getMaxTime();\n\n      for (var k = 0; k < tracks.length; k++) {\n        var track = tracks[k];\n\n        if (track.needsAnimate()) {\n          var kfs = track.keyframes;\n          var attrName = track.propName;\n          toCssAttrName && (attrName = toCssAttrName(attrName));\n\n          if (attrName) {\n            for (var i = 0; i < kfs.length; i++) {\n              var kf = kfs[i];\n              var percent = Math.round(kf.time / maxTime * 100) + '%';\n              var kfEasing = getEasingFunc(kf.easing);\n              var rawValue = kf.rawValue;\n\n              if (isString(rawValue) || isNumber(rawValue)) {\n                cssKfs[percent] = cssKfs[percent] || {};\n                cssKfs[percent][attrName] = kf.rawValue;\n\n                if (kfEasing) {\n                  cssKfs[percent][animationTimingFunctionAttrName] = kfEasing;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    for (var i = 0; i < len; i++) {\n      var animator = animators[i];\n      var targetProp = animator.targetName;\n\n      if (!targetProp) {\n        !onlyShape && saveAnimatorTrackToCssKfs(animator, transformKfs);\n      } else if (targetProp === 'shape') {\n        saveAnimatorTrackToCssKfs(animator, shapeKfs);\n      }\n    }\n\n    for (var percent in transformKfs) {\n      var transform = {};\n      copyTransform(transform, el);\n      extend(transform, transformKfs[percent]);\n      var str = getSRTTransformString(transform);\n      var timingFunction = transformKfs[percent][animationTimingFunctionAttrName];\n      finalKfs[percent] = str ? {\n        transform: str\n      } : {};\n      setTransformOrigin(finalKfs[percent], transform);\n\n      if (timingFunction) {\n        finalKfs[percent][animationTimingFunctionAttrName] = timingFunction;\n      }\n    }\n\n    ;\n    var path;\n    var canAnimateShape = true;\n\n    for (var percent in shapeKfs) {\n      finalKfs[percent] = finalKfs[percent] || {};\n      var isFirst = !path;\n      var timingFunction = shapeKfs[percent][animationTimingFunctionAttrName];\n\n      if (isFirst) {\n        path = new PathProxy();\n      }\n\n      var len_1 = path.len();\n      path.reset();\n      finalKfs[percent].d = buildPathString(el, shapeKfs[percent], path);\n      var newLen = path.len();\n\n      if (!isFirst && len_1 !== newLen) {\n        canAnimateShape = false;\n        break;\n      }\n\n      if (timingFunction) {\n        finalKfs[percent][animationTimingFunctionAttrName] = timingFunction;\n      }\n    }\n\n    ;\n\n    if (!canAnimateShape) {\n      for (var percent in finalKfs) {\n        delete finalKfs[percent].d;\n      }\n    }\n\n    if (!onlyShape) {\n      for (var i = 0; i < len; i++) {\n        var animator = animators[i];\n        var targetProp = animator.targetName;\n\n        if (targetProp === 'style') {\n          saveAnimatorTrackToCssKfs(animator, finalKfs, function (propName) {\n            return ANIMATE_STYLE_MAP[propName];\n          });\n        }\n      }\n    }\n\n    var percents = keys(finalKfs);\n    var allTransformOriginSame = true;\n    var transformOrigin;\n\n    for (var i = 1; i < percents.length; i++) {\n      var p0 = percents[i - 1];\n      var p1 = percents[i];\n\n      if (finalKfs[p0][transformOriginKey] !== finalKfs[p1][transformOriginKey]) {\n        allTransformOriginSame = false;\n        break;\n      }\n\n      transformOrigin = finalKfs[p0][transformOriginKey];\n    }\n\n    if (allTransformOriginSame && transformOrigin) {\n      for (var percent in finalKfs) {\n        if (finalKfs[percent][transformOriginKey]) {\n          delete finalKfs[percent][transformOriginKey];\n        }\n      }\n\n      attrs[transformOriginKey] = transformOrigin;\n    }\n\n    if (filter(percents, function (percent) {\n      return keys(finalKfs[percent]).length > 0;\n    }).length) {\n      var animationName = addAnimation(finalKfs, scope);\n      return animationName + \" \" + groupAnimator[0] + \" both\";\n    }\n  }\n\n  for (var key in groupAnimators) {\n    var animationCfg = createSingleCSSAnimation(groupAnimators[key]);\n\n    if (animationCfg) {\n      cssAnimations.push(animationCfg);\n    }\n  }\n\n  if (cssAnimations.length) {\n    var className = scope.zrId + '-cls-' + scope.cssClassIdx++;\n    scope.cssNodes['.' + className] = {\n      animation: cssAnimations.join(',')\n    };\n    attrs[\"class\"] = className;\n  }\n}","map":{"version":3,"sources":["F:/Desktop/two_hours_front/node_modules/zrender/lib/svg/cssAnimation.js"],"names":["copyTransform","createBrushScope","SVGPathRebuilder","PathProxy","getPathPrecision","getSRTTransformString","each","extend","filter","isNumber","isString","keys","CompoundPath","createCubicEasingFunc","EASING_MAP","cubicIn","cubicOut","cubicInOut","quadraticIn","quadraticOut","quadraticInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","transformOriginKey","buildPathString","el","kfShape","path","shape","buildPath","svgPathBuilder","reset","rebuildPath","generateStr","getStr","setTransformOrigin","target","transform","originX","originY","ANIMATE_STYLE_MAP","fill","opacity","lineWidth","lineDashOffset","addAnimation","cssAnim","scope","animationName","zrId","cssAnimIdx","cssAnims","createCompoundPathCSSAnimation","attrs","paths","composedAnim","cssAnimationCfg","cssAnimationName","subScope","animation","createCSSAnimation","cssNodes","animNames","len","length","lastAnim","percent","kf","d","className","val","indexOf","replace","getEasingFunc","easing","onlyShape","animators","cssAnimations","animationCfg","push","groupAnimators","i","animator","cfgArr","getMaxTime","getClip","delay","getDelay","getLoop","cfg","join","createSingleCSSAnimation","groupAnimator","transformKfs","shapeKfs","finalKfs","animationTimingFunctionAttrName","saveAnimatorTrackToCssKfs","cssKfs","toCssAttrName","tracks","getTracks","maxTime","k","track","needsAnimate","kfs","keyframes","attrName","propName","Math","round","time","kfEasing","rawValue","targetProp","targetName","str","timingFunction","canAnimateShape","isFirst","len_1","newLen","percents","allTransformOriginSame","transformOrigin","p0","p1","key","cssClassIdx"],"mappings":"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","sourcesContent":["import { copyTransform } from '../core/Transformable.js';\nimport { createBrushScope } from './core.js';\nimport SVGPathRebuilder from './SVGPathRebuilder.js';\nimport PathProxy from '../core/PathProxy.js';\nimport { getPathPrecision, getSRTTransformString } from './helper.js';\nimport { each, extend, filter, isNumber, isString, keys } from '../core/util.js';\nimport CompoundPath from '../graphic/CompoundPath.js';\nimport { createCubicEasingFunc } from '../animation/cubicEasing.js';\nexport var EASING_MAP = {\n    cubicIn: '0.32,0,0.67,0',\n    cubicOut: '0.33,1,0.68,1',\n    cubicInOut: '0.65,0,0.35,1',\n    quadraticIn: '0.11,0,0.5,0',\n    quadraticOut: '0.5,1,0.89,1',\n    quadraticInOut: '0.45,0,0.55,1',\n    quarticIn: '0.5,0,0.75,0',\n    quarticOut: '0.25,1,0.5,1',\n    quarticInOut: '0.76,0,0.24,1',\n    quinticIn: '0.64,0,0.78,0',\n    quinticOut: '0.22,1,0.36,1',\n    quinticInOut: '0.83,0,0.17,1',\n    sinusoidalIn: '0.12,0,0.39,0',\n    sinusoidalOut: '0.61,1,0.88,1',\n    sinusoidalInOut: '0.37,0,0.63,1',\n    exponentialIn: '0.7,0,0.84,0',\n    exponentialOut: '0.16,1,0.3,1',\n    exponentialInOut: '0.87,0,0.13,1',\n    circularIn: '0.55,0,1,0.45',\n    circularOut: '0,0.55,0.45,1',\n    circularInOut: '0.85,0,0.15,1'\n};\nvar transformOriginKey = 'transform-origin';\nfunction buildPathString(el, kfShape, path) {\n    var shape = extend({}, el.shape);\n    extend(shape, kfShape);\n    el.buildPath(path, shape);\n    var svgPathBuilder = new SVGPathRebuilder();\n    svgPathBuilder.reset(getPathPrecision(el));\n    path.rebuildPath(svgPathBuilder, 1);\n    svgPathBuilder.generateStr();\n    return svgPathBuilder.getStr();\n}\nfunction setTransformOrigin(target, transform) {\n    var originX = transform.originX, originY = transform.originY;\n    if (originX || originY) {\n        target[transformOriginKey] = originX + \"px \" + originY + \"px\";\n    }\n}\nexport var ANIMATE_STYLE_MAP = {\n    fill: 'fill',\n    opacity: 'opacity',\n    lineWidth: 'stroke-width',\n    lineDashOffset: 'stroke-dashoffset'\n};\nfunction addAnimation(cssAnim, scope) {\n    var animationName = scope.zrId + '-ani-' + scope.cssAnimIdx++;\n    scope.cssAnims[animationName] = cssAnim;\n    return animationName;\n}\nfunction createCompoundPathCSSAnimation(el, attrs, scope) {\n    var paths = el.shape.paths;\n    var composedAnim = {};\n    var cssAnimationCfg;\n    var cssAnimationName;\n    each(paths, function (path) {\n        var subScope = createBrushScope(scope.zrId);\n        subScope.animation = true;\n        createCSSAnimation(path, {}, subScope, true);\n        var cssAnims = subScope.cssAnims;\n        var cssNodes = subScope.cssNodes;\n        var animNames = keys(cssAnims);\n        var len = animNames.length;\n        if (!len) {\n            return;\n        }\n        cssAnimationName = animNames[len - 1];\n        var lastAnim = cssAnims[cssAnimationName];\n        for (var percent in lastAnim) {\n            var kf = lastAnim[percent];\n            composedAnim[percent] = composedAnim[percent] || { d: '' };\n            composedAnim[percent].d += kf.d || '';\n        }\n        for (var className in cssNodes) {\n            var val = cssNodes[className].animation;\n            if (val.indexOf(cssAnimationName) >= 0) {\n                cssAnimationCfg = val;\n            }\n        }\n    });\n    if (!cssAnimationCfg) {\n        return;\n    }\n    attrs.d = false;\n    var animationName = addAnimation(composedAnim, scope);\n    return cssAnimationCfg.replace(cssAnimationName, animationName);\n}\nfunction getEasingFunc(easing) {\n    return isString(easing)\n        ? EASING_MAP[easing]\n            ? \"cubic-bezier(\" + EASING_MAP[easing] + \")\"\n            : createCubicEasingFunc(easing) ? easing : ''\n        : '';\n}\nexport function createCSSAnimation(el, attrs, scope, onlyShape) {\n    var animators = el.animators;\n    var len = animators.length;\n    var cssAnimations = [];\n    if (el instanceof CompoundPath) {\n        var animationCfg = createCompoundPathCSSAnimation(el, attrs, scope);\n        if (animationCfg) {\n            cssAnimations.push(animationCfg);\n        }\n        else if (!len) {\n            return;\n        }\n    }\n    else if (!len) {\n        return;\n    }\n    var groupAnimators = {};\n    for (var i = 0; i < len; i++) {\n        var animator = animators[i];\n        var cfgArr = [animator.getMaxTime() / 1000 + 's'];\n        var easing = getEasingFunc(animator.getClip().easing);\n        var delay = animator.getDelay();\n        if (easing) {\n            cfgArr.push(easing);\n        }\n        else {\n            cfgArr.push('linear');\n        }\n        if (delay) {\n            cfgArr.push(delay / 1000 + 's');\n        }\n        if (animator.getLoop()) {\n            cfgArr.push('infinite');\n        }\n        var cfg = cfgArr.join(' ');\n        groupAnimators[cfg] = groupAnimators[cfg] || [cfg, []];\n        groupAnimators[cfg][1].push(animator);\n    }\n    function createSingleCSSAnimation(groupAnimator) {\n        var animators = groupAnimator[1];\n        var len = animators.length;\n        var transformKfs = {};\n        var shapeKfs = {};\n        var finalKfs = {};\n        var animationTimingFunctionAttrName = 'animation-timing-function';\n        function saveAnimatorTrackToCssKfs(animator, cssKfs, toCssAttrName) {\n            var tracks = animator.getTracks();\n            var maxTime = animator.getMaxTime();\n            for (var k = 0; k < tracks.length; k++) {\n                var track = tracks[k];\n                if (track.needsAnimate()) {\n                    var kfs = track.keyframes;\n                    var attrName = track.propName;\n                    toCssAttrName && (attrName = toCssAttrName(attrName));\n                    if (attrName) {\n                        for (var i = 0; i < kfs.length; i++) {\n                            var kf = kfs[i];\n                            var percent = Math.round(kf.time / maxTime * 100) + '%';\n                            var kfEasing = getEasingFunc(kf.easing);\n                            var rawValue = kf.rawValue;\n                            if (isString(rawValue) || isNumber(rawValue)) {\n                                cssKfs[percent] = cssKfs[percent] || {};\n                                cssKfs[percent][attrName] = kf.rawValue;\n                                if (kfEasing) {\n                                    cssKfs[percent][animationTimingFunctionAttrName] = kfEasing;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for (var i = 0; i < len; i++) {\n            var animator = animators[i];\n            var targetProp = animator.targetName;\n            if (!targetProp) {\n                !onlyShape && saveAnimatorTrackToCssKfs(animator, transformKfs);\n            }\n            else if (targetProp === 'shape') {\n                saveAnimatorTrackToCssKfs(animator, shapeKfs);\n            }\n        }\n        for (var percent in transformKfs) {\n            var transform = {};\n            copyTransform(transform, el);\n            extend(transform, transformKfs[percent]);\n            var str = getSRTTransformString(transform);\n            var timingFunction = transformKfs[percent][animationTimingFunctionAttrName];\n            finalKfs[percent] = str ? {\n                transform: str\n            } : {};\n            setTransformOrigin(finalKfs[percent], transform);\n            if (timingFunction) {\n                finalKfs[percent][animationTimingFunctionAttrName] = timingFunction;\n            }\n        }\n        ;\n        var path;\n        var canAnimateShape = true;\n        for (var percent in shapeKfs) {\n            finalKfs[percent] = finalKfs[percent] || {};\n            var isFirst = !path;\n            var timingFunction = shapeKfs[percent][animationTimingFunctionAttrName];\n            if (isFirst) {\n                path = new PathProxy();\n            }\n            var len_1 = path.len();\n            path.reset();\n            finalKfs[percent].d = buildPathString(el, shapeKfs[percent], path);\n            var newLen = path.len();\n            if (!isFirst && len_1 !== newLen) {\n                canAnimateShape = false;\n                break;\n            }\n            if (timingFunction) {\n                finalKfs[percent][animationTimingFunctionAttrName] = timingFunction;\n            }\n        }\n        ;\n        if (!canAnimateShape) {\n            for (var percent in finalKfs) {\n                delete finalKfs[percent].d;\n            }\n        }\n        if (!onlyShape) {\n            for (var i = 0; i < len; i++) {\n                var animator = animators[i];\n                var targetProp = animator.targetName;\n                if (targetProp === 'style') {\n                    saveAnimatorTrackToCssKfs(animator, finalKfs, function (propName) { return ANIMATE_STYLE_MAP[propName]; });\n                }\n            }\n        }\n        var percents = keys(finalKfs);\n        var allTransformOriginSame = true;\n        var transformOrigin;\n        for (var i = 1; i < percents.length; i++) {\n            var p0 = percents[i - 1];\n            var p1 = percents[i];\n            if (finalKfs[p0][transformOriginKey] !== finalKfs[p1][transformOriginKey]) {\n                allTransformOriginSame = false;\n                break;\n            }\n            transformOrigin = finalKfs[p0][transformOriginKey];\n        }\n        if (allTransformOriginSame && transformOrigin) {\n            for (var percent in finalKfs) {\n                if (finalKfs[percent][transformOriginKey]) {\n                    delete finalKfs[percent][transformOriginKey];\n                }\n            }\n            attrs[transformOriginKey] = transformOrigin;\n        }\n        if (filter(percents, function (percent) { return keys(finalKfs[percent]).length > 0; }).length) {\n            var animationName = addAnimation(finalKfs, scope);\n            return animationName + \" \" + groupAnimator[0] + \" both\";\n        }\n    }\n    for (var key in groupAnimators) {\n        var animationCfg = createSingleCSSAnimation(groupAnimators[key]);\n        if (animationCfg) {\n            cssAnimations.push(animationCfg);\n        }\n    }\n    if (cssAnimations.length) {\n        var className = scope.zrId + '-cls-' + scope.cssClassIdx++;\n        scope.cssNodes['.' + className] = {\n            animation: cssAnimations.join(',')\n        };\n        attrs[\"class\"] = className;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}