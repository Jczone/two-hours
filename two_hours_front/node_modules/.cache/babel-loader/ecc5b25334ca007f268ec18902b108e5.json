{"ast":null,"code":"import \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.match.js\";\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// FIXME emphasis label position is not same with normal label position\nimport { parsePercent } from '../../util/number.js';\nimport { Point } from '../../util/graphic.js';\nimport { each, isNumber } from 'zrender/lib/core/util.js';\nimport { limitTurnAngle, limitSurfaceAngle } from '../../label/labelGuideHelper.js';\nimport { shiftLayoutOnY } from '../../label/labelLayoutHelper.js';\nvar RADIAN = Math.PI / 180;\n\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {\n  if (list.length < 2) {\n    return;\n  }\n\n  ;\n\n  function recalculateXOnSemiToAlignOnEllipseCurve(semi) {\n    var rB = semi.rB;\n    var rB2 = rB * rB;\n\n    for (var i = 0; i < semi.list.length; i++) {\n      var item = semi.list[i];\n      var dy = Math.abs(item.label.y - cy); // horizontal r is always same with original r because x is not changed.\n\n      var rA = r + item.len;\n      var rA2 = rA * rA; // Use ellipse implicit function to calculate x\n\n      var dx = Math.sqrt((1 - Math.abs(dy * dy / rB2)) * rA2);\n      var newX = cx + (dx + item.len2) * dir;\n      var deltaX = newX - item.label.x;\n      var newTargetWidth = item.targetTextWidth - deltaX * dir; // text x is changed, so need to recalculate width.\n\n      constrainTextWidth(item, newTargetWidth, true);\n      item.label.x = newX;\n    }\n  } // Adjust X based on the shifted y. Make tight labels aligned on an ellipse curve.\n\n\n  function recalculateX(items) {\n    // Extremes of\n    var topSemi = {\n      list: [],\n      maxY: 0\n    };\n    var bottomSemi = {\n      list: [],\n      maxY: 0\n    };\n\n    for (var i = 0; i < items.length; i++) {\n      if (items[i].labelAlignTo !== 'none') {\n        continue;\n      }\n\n      var item = items[i];\n      var semi = item.label.y > cy ? bottomSemi : topSemi;\n      var dy = Math.abs(item.label.y - cy);\n\n      if (dy >= semi.maxY) {\n        var dx = item.label.x - cx - item.len2 * dir; // horizontal r is always same with original r because x is not changed.\n\n        var rA = r + item.len; // Canculate rB based on the topest / bottemest label.\n\n        var rB = Math.abs(dx) < rA ? Math.sqrt(dy * dy / (1 - dx * dx / rA / rA)) : rA;\n        semi.rB = rB;\n        semi.maxY = dy;\n      }\n\n      semi.list.push(item);\n    }\n\n    recalculateXOnSemiToAlignOnEllipseCurve(topSemi);\n    recalculateXOnSemiToAlignOnEllipseCurve(bottomSemi);\n  }\n\n  var len = list.length;\n\n  for (var i = 0; i < len; i++) {\n    if (list[i].position === 'outer' && list[i].labelAlignTo === 'labelLine') {\n      var dx = list[i].label.x - farthestX;\n      list[i].linePoints[1][0] += dx;\n      list[i].label.x = farthestX;\n    }\n  }\n\n  if (shiftLayoutOnY(list, viewTop, viewTop + viewHeight)) {\n    recalculateX(list);\n  }\n}\n\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {\n  var leftList = [];\n  var rightList = [];\n  var leftmostX = Number.MAX_VALUE;\n  var rightmostX = -Number.MAX_VALUE;\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var label = labelLayoutList[i].label;\n\n    if (isPositionCenter(labelLayoutList[i])) {\n      continue;\n    }\n\n    if (label.x < cx) {\n      leftmostX = Math.min(leftmostX, label.x);\n      leftList.push(labelLayoutList[i]);\n    } else {\n      rightmostX = Math.max(rightmostX, label.x);\n      rightList.push(labelLayoutList[i]);\n    }\n  }\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var layout = labelLayoutList[i];\n\n    if (!isPositionCenter(layout) && layout.linePoints) {\n      if (layout.labelStyleWidth != null) {\n        continue;\n      }\n\n      var label = layout.label;\n      var linePoints = layout.linePoints;\n      var targetTextWidth = void 0;\n\n      if (layout.labelAlignTo === 'edge') {\n        if (label.x < cx) {\n          targetTextWidth = linePoints[2][0] - layout.labelDistance - viewLeft - layout.edgeDistance;\n        } else {\n          targetTextWidth = viewLeft + viewWidth - layout.edgeDistance - linePoints[2][0] - layout.labelDistance;\n        }\n      } else if (layout.labelAlignTo === 'labelLine') {\n        if (label.x < cx) {\n          targetTextWidth = leftmostX - viewLeft - layout.bleedMargin;\n        } else {\n          targetTextWidth = viewLeft + viewWidth - rightmostX - layout.bleedMargin;\n        }\n      } else {\n        if (label.x < cx) {\n          targetTextWidth = label.x - viewLeft - layout.bleedMargin;\n        } else {\n          targetTextWidth = viewLeft + viewWidth - label.x - layout.bleedMargin;\n        }\n      }\n\n      layout.targetTextWidth = targetTextWidth;\n      constrainTextWidth(layout, targetTextWidth);\n    }\n  }\n\n  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);\n  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var layout = labelLayoutList[i];\n\n    if (!isPositionCenter(layout) && layout.linePoints) {\n      var label = layout.label;\n      var linePoints = layout.linePoints;\n      var isAlignToEdge = layout.labelAlignTo === 'edge';\n      var padding = label.style.padding;\n      var paddingH = padding ? padding[1] + padding[3] : 0; // textRect.width already contains paddingH if bgColor is set\n\n      var extraPaddingH = label.style.backgroundColor ? 0 : paddingH;\n      var realTextWidth = layout.rect.width + extraPaddingH;\n      var dist = linePoints[1][0] - linePoints[2][0];\n\n      if (isAlignToEdge) {\n        if (label.x < cx) {\n          linePoints[2][0] = viewLeft + layout.edgeDistance + realTextWidth + layout.labelDistance;\n        } else {\n          linePoints[2][0] = viewLeft + viewWidth - layout.edgeDistance - realTextWidth - layout.labelDistance;\n        }\n      } else {\n        if (label.x < cx) {\n          linePoints[2][0] = label.x + layout.labelDistance;\n        } else {\n          linePoints[2][0] = label.x - layout.labelDistance;\n        }\n\n        linePoints[1][0] = linePoints[2][0] + dist;\n      }\n\n      linePoints[1][1] = linePoints[2][1] = label.y;\n    }\n  }\n}\n/**\r\n * Set max width of each label, and then wrap each label to the max width.\r\n *\r\n * @param layout label layout\r\n * @param availableWidth max width for the label to display\r\n * @param forceRecalculate recaculate the text layout even if the current width\r\n * is smaller than `availableWidth`. This is useful when the text was previously\r\n * wrapped by calling `constrainTextWidth` but now `availableWidth` changed, in\r\n * which case, previous wrapping should be redo.\r\n */\n\n\nfunction constrainTextWidth(layout, availableWidth, forceRecalculate) {\n  if (forceRecalculate === void 0) {\n    forceRecalculate = false;\n  }\n\n  if (layout.labelStyleWidth != null) {\n    // User-defined style.width has the highest priority.\n    return;\n  }\n\n  var label = layout.label;\n  var style = label.style;\n  var textRect = layout.rect;\n  var bgColor = style.backgroundColor;\n  var padding = style.padding;\n  var paddingH = padding ? padding[1] + padding[3] : 0;\n  var overflow = style.overflow; // textRect.width already contains paddingH if bgColor is set\n\n  var oldOuterWidth = textRect.width + (bgColor ? 0 : paddingH);\n\n  if (availableWidth < oldOuterWidth || forceRecalculate) {\n    var oldHeight = textRect.height;\n\n    if (overflow && overflow.match('break')) {\n      // Temporarily set background to be null to calculate\n      // the bounding box without backgroud.\n      label.setStyle('backgroundColor', null); // Set constraining width\n\n      label.setStyle('width', availableWidth - paddingH); // This is the real bounding box of the text without padding\n\n      var innerRect = label.getBoundingRect();\n      label.setStyle('width', Math.ceil(innerRect.width));\n      label.setStyle('backgroundColor', bgColor);\n    } else {\n      var availableInnerWidth = availableWidth - paddingH;\n      var newWidth = availableWidth < oldOuterWidth // Current text is too wide, use `availableWidth` as max width.\n      ? availableInnerWidth : // Current available width is enough, but the text may have\n      // already been wrapped with a smaller available width.\n      forceRecalculate ? availableInnerWidth > layout.unconstrainedWidth // Current available is larger than text width,\n      // so don't constrain width (otherwise it may have\n      // empty space in the background).\n      ? null // Current available is smaller than text width, so\n      // use the current available width as constraining\n      // width.\n      : availableInnerWidth : // Current available width is enough, so no need to\n      // constrain.\n      null;\n      label.setStyle('width', newWidth);\n    }\n\n    var newRect = label.getBoundingRect();\n    textRect.width = newRect.width;\n    var margin = (label.style.margin || 0) + 2.1;\n    textRect.height = newRect.height + margin;\n    textRect.y -= (textRect.height - oldHeight) / 2;\n  }\n}\n\nfunction isPositionCenter(sectorShape) {\n  // Not change x for center label\n  return sectorShape.position === 'center';\n}\n\nexport default function pieLabelLayout(seriesModel) {\n  var data = seriesModel.getData();\n  var labelLayoutList = [];\n  var cx;\n  var cy;\n  var hasLabelRotate = false;\n  var minShowLabelRadian = (seriesModel.get('minShowLabelAngle') || 0) * RADIAN;\n  var viewRect = data.getLayout('viewRect');\n  var r = data.getLayout('r');\n  var viewWidth = viewRect.width;\n  var viewLeft = viewRect.x;\n  var viewTop = viewRect.y;\n  var viewHeight = viewRect.height;\n\n  function setNotShow(el) {\n    el.ignore = true;\n  }\n\n  function isLabelShown(label) {\n    if (!label.ignore) {\n      return true;\n    }\n\n    for (var key in label.states) {\n      if (label.states[key].ignore === false) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  data.each(function (idx) {\n    var sector = data.getItemGraphicEl(idx);\n    var sectorShape = sector.shape;\n    var label = sector.getTextContent();\n    var labelLine = sector.getTextGuideLine();\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis\n\n    var labelPosition = labelModel.get('position') || itemModel.get(['emphasis', 'label', 'position']);\n    var labelDistance = labelModel.get('distanceToLabelLine');\n    var labelAlignTo = labelModel.get('alignTo');\n    var edgeDistance = parsePercent(labelModel.get('edgeDistance'), viewWidth);\n    var bleedMargin = labelModel.get('bleedMargin');\n    var labelLineModel = itemModel.getModel('labelLine');\n    var labelLineLen = labelLineModel.get('length');\n    labelLineLen = parsePercent(labelLineLen, viewWidth);\n    var labelLineLen2 = labelLineModel.get('length2');\n    labelLineLen2 = parsePercent(labelLineLen2, viewWidth);\n\n    if (Math.abs(sectorShape.endAngle - sectorShape.startAngle) < minShowLabelRadian) {\n      each(label.states, setNotShow);\n      label.ignore = true;\n      return;\n    }\n\n    if (!isLabelShown(label)) {\n      return;\n    }\n\n    var midAngle = (sectorShape.startAngle + sectorShape.endAngle) / 2;\n    var nx = Math.cos(midAngle);\n    var ny = Math.sin(midAngle);\n    var textX;\n    var textY;\n    var linePoints;\n    var textAlign;\n    cx = sectorShape.cx;\n    cy = sectorShape.cy;\n    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\n    if (labelPosition === 'center') {\n      textX = sectorShape.cx;\n      textY = sectorShape.cy;\n      textAlign = 'center';\n    } else {\n      var x1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * nx : sectorShape.r * nx) + cx;\n      var y1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * ny : sectorShape.r * ny) + cy;\n      textX = x1 + nx * 3;\n      textY = y1 + ny * 3;\n\n      if (!isLabelInside) {\n        // For roseType\n        var x2 = x1 + nx * (labelLineLen + r - sectorShape.r);\n        var y2 = y1 + ny * (labelLineLen + r - sectorShape.r);\n        var x3 = x2 + (nx < 0 ? -1 : 1) * labelLineLen2;\n        var y3 = y2;\n\n        if (labelAlignTo === 'edge') {\n          // Adjust textX because text align of edge is opposite\n          textX = nx < 0 ? viewLeft + edgeDistance : viewLeft + viewWidth - edgeDistance;\n        } else {\n          textX = x3 + (nx < 0 ? -labelDistance : labelDistance);\n        }\n\n        textY = y3;\n        linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n      }\n\n      textAlign = isLabelInside ? 'center' : labelAlignTo === 'edge' ? nx > 0 ? 'right' : 'left' : nx > 0 ? 'left' : 'right';\n    }\n\n    var PI = Math.PI;\n    var labelRotate = 0;\n    var rotate = labelModel.get('rotate');\n\n    if (isNumber(rotate)) {\n      labelRotate = rotate * (PI / 180);\n    } else if (labelPosition === 'center') {\n      labelRotate = 0;\n    } else if (rotate === 'radial' || rotate === true) {\n      var radialAngle = nx < 0 ? -midAngle + PI : -midAngle;\n      labelRotate = radialAngle;\n    } else if (rotate === 'tangential' && labelPosition !== 'outside' && labelPosition !== 'outer') {\n      var rad = Math.atan2(nx, ny);\n\n      if (rad < 0) {\n        rad = PI * 2 + rad;\n      }\n\n      var isDown = ny > 0;\n\n      if (isDown) {\n        rad = PI + rad;\n      }\n\n      labelRotate = rad - PI;\n    }\n\n    hasLabelRotate = !!labelRotate;\n    label.x = textX;\n    label.y = textY;\n    label.rotation = labelRotate;\n    label.setStyle({\n      verticalAlign: 'middle'\n    }); // Not sectorShape the inside label\n\n    if (!isLabelInside) {\n      var textRect = label.getBoundingRect().clone();\n      textRect.applyTransform(label.getComputedTransform()); // Text has a default 1px stroke. Exclude this.\n\n      var margin = (label.style.margin || 0) + 2.1;\n      textRect.y -= margin / 2;\n      textRect.height += margin;\n      labelLayoutList.push({\n        label: label,\n        labelLine: labelLine,\n        position: labelPosition,\n        len: labelLineLen,\n        len2: labelLineLen2,\n        minTurnAngle: labelLineModel.get('minTurnAngle'),\n        maxSurfaceAngle: labelLineModel.get('maxSurfaceAngle'),\n        surfaceNormal: new Point(nx, ny),\n        linePoints: linePoints,\n        textAlign: textAlign,\n        labelDistance: labelDistance,\n        labelAlignTo: labelAlignTo,\n        edgeDistance: edgeDistance,\n        bleedMargin: bleedMargin,\n        rect: textRect,\n        unconstrainedWidth: textRect.width,\n        labelStyleWidth: label.style.width\n      });\n    } else {\n      label.setStyle({\n        align: textAlign\n      });\n      var selectState = label.states.select;\n\n      if (selectState) {\n        selectState.x += label.x;\n        selectState.y += label.y;\n      }\n    }\n\n    sector.setTextConfig({\n      inside: isLabelInside\n    });\n  });\n\n  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);\n  }\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var layout = labelLayoutList[i];\n    var label = layout.label;\n    var labelLine = layout.labelLine;\n    var notShowLabel = isNaN(label.x) || isNaN(label.y);\n\n    if (label) {\n      label.setStyle({\n        align: layout.textAlign\n      });\n\n      if (notShowLabel) {\n        each(label.states, setNotShow);\n        label.ignore = true;\n      }\n\n      var selectState = label.states.select;\n\n      if (selectState) {\n        selectState.x += label.x;\n        selectState.y += label.y;\n      }\n    }\n\n    if (labelLine) {\n      var linePoints = layout.linePoints;\n\n      if (notShowLabel || !linePoints) {\n        each(labelLine.states, setNotShow);\n        labelLine.ignore = true;\n      } else {\n        limitTurnAngle(linePoints, layout.minTurnAngle);\n        limitSurfaceAngle(linePoints, layout.surfaceNormal, layout.maxSurfaceAngle);\n        labelLine.setShape({\n          points: linePoints\n        }); // Set the anchor to the midpoint of sector\n\n        label.__hostTarget.textGuideLineConfig = {\n          anchor: new Point(linePoints[0][0], linePoints[0][1])\n        };\n      }\n    }\n  }\n}","map":{"version":3,"sources":["F:/Desktop/繁星教育/TH资料/two_hours_front/node_modules/echarts/lib/chart/pie/labelLayout.js"],"names":["parsePercent","Point","each","isNumber","limitTurnAngle","limitSurfaceAngle","shiftLayoutOnY","RADIAN","Math","PI","adjustSingleSide","list","cx","cy","r","dir","viewWidth","viewHeight","viewLeft","viewTop","farthestX","length","recalculateXOnSemiToAlignOnEllipseCurve","semi","rB","rB2","i","item","dy","abs","label","y","rA","len","rA2","dx","sqrt","newX","len2","deltaX","x","newTargetWidth","targetTextWidth","constrainTextWidth","recalculateX","items","topSemi","maxY","bottomSemi","labelAlignTo","push","position","linePoints","avoidOverlap","labelLayoutList","leftList","rightList","leftmostX","Number","MAX_VALUE","rightmostX","isPositionCenter","min","max","layout","labelStyleWidth","labelDistance","edgeDistance","bleedMargin","isAlignToEdge","padding","style","paddingH","extraPaddingH","backgroundColor","realTextWidth","rect","width","dist","availableWidth","forceRecalculate","textRect","bgColor","overflow","oldOuterWidth","oldHeight","height","match","setStyle","innerRect","getBoundingRect","ceil","availableInnerWidth","newWidth","unconstrainedWidth","newRect","margin","sectorShape","pieLabelLayout","seriesModel","data","getData","hasLabelRotate","minShowLabelRadian","get","viewRect","getLayout","setNotShow","el","ignore","isLabelShown","key","states","idx","sector","getItemGraphicEl","shape","getTextContent","labelLine","getTextGuideLine","itemModel","getItemModel","labelModel","getModel","labelPosition","labelLineModel","labelLineLen","labelLineLen2","endAngle","startAngle","midAngle","nx","cos","ny","sin","textX","textY","textAlign","isLabelInside","x1","r0","y1","x2","y2","x3","y3","labelRotate","rotate","radialAngle","rad","atan2","isDown","rotation","verticalAlign","clone","applyTransform","getComputedTransform","minTurnAngle","maxSurfaceAngle","surfaceNormal","align","selectState","select","setTextConfig","inside","notShowLabel","isNaN","setShape","points","__hostTarget","textGuideLineConfig","anchor"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// FIXME emphasis label position is not same with normal label position\nimport { parsePercent } from '../../util/number.js';\nimport { Point } from '../../util/graphic.js';\nimport { each, isNumber } from 'zrender/lib/core/util.js';\nimport { limitTurnAngle, limitSurfaceAngle } from '../../label/labelGuideHelper.js';\nimport { shiftLayoutOnY } from '../../label/labelLayoutHelper.js';\nvar RADIAN = Math.PI / 180;\n\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {\n  if (list.length < 2) {\n    return;\n  }\n\n  ;\n\n  function recalculateXOnSemiToAlignOnEllipseCurve(semi) {\n    var rB = semi.rB;\n    var rB2 = rB * rB;\n\n    for (var i = 0; i < semi.list.length; i++) {\n      var item = semi.list[i];\n      var dy = Math.abs(item.label.y - cy); // horizontal r is always same with original r because x is not changed.\n\n      var rA = r + item.len;\n      var rA2 = rA * rA; // Use ellipse implicit function to calculate x\n\n      var dx = Math.sqrt((1 - Math.abs(dy * dy / rB2)) * rA2);\n      var newX = cx + (dx + item.len2) * dir;\n      var deltaX = newX - item.label.x;\n      var newTargetWidth = item.targetTextWidth - deltaX * dir; // text x is changed, so need to recalculate width.\n\n      constrainTextWidth(item, newTargetWidth, true);\n      item.label.x = newX;\n    }\n  } // Adjust X based on the shifted y. Make tight labels aligned on an ellipse curve.\n\n\n  function recalculateX(items) {\n    // Extremes of\n    var topSemi = {\n      list: [],\n      maxY: 0\n    };\n    var bottomSemi = {\n      list: [],\n      maxY: 0\n    };\n\n    for (var i = 0; i < items.length; i++) {\n      if (items[i].labelAlignTo !== 'none') {\n        continue;\n      }\n\n      var item = items[i];\n      var semi = item.label.y > cy ? bottomSemi : topSemi;\n      var dy = Math.abs(item.label.y - cy);\n\n      if (dy >= semi.maxY) {\n        var dx = item.label.x - cx - item.len2 * dir; // horizontal r is always same with original r because x is not changed.\n\n        var rA = r + item.len; // Canculate rB based on the topest / bottemest label.\n\n        var rB = Math.abs(dx) < rA ? Math.sqrt(dy * dy / (1 - dx * dx / rA / rA)) : rA;\n        semi.rB = rB;\n        semi.maxY = dy;\n      }\n\n      semi.list.push(item);\n    }\n\n    recalculateXOnSemiToAlignOnEllipseCurve(topSemi);\n    recalculateXOnSemiToAlignOnEllipseCurve(bottomSemi);\n  }\n\n  var len = list.length;\n\n  for (var i = 0; i < len; i++) {\n    if (list[i].position === 'outer' && list[i].labelAlignTo === 'labelLine') {\n      var dx = list[i].label.x - farthestX;\n      list[i].linePoints[1][0] += dx;\n      list[i].label.x = farthestX;\n    }\n  }\n\n  if (shiftLayoutOnY(list, viewTop, viewTop + viewHeight)) {\n    recalculateX(list);\n  }\n}\n\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {\n  var leftList = [];\n  var rightList = [];\n  var leftmostX = Number.MAX_VALUE;\n  var rightmostX = -Number.MAX_VALUE;\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var label = labelLayoutList[i].label;\n\n    if (isPositionCenter(labelLayoutList[i])) {\n      continue;\n    }\n\n    if (label.x < cx) {\n      leftmostX = Math.min(leftmostX, label.x);\n      leftList.push(labelLayoutList[i]);\n    } else {\n      rightmostX = Math.max(rightmostX, label.x);\n      rightList.push(labelLayoutList[i]);\n    }\n  }\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var layout = labelLayoutList[i];\n\n    if (!isPositionCenter(layout) && layout.linePoints) {\n      if (layout.labelStyleWidth != null) {\n        continue;\n      }\n\n      var label = layout.label;\n      var linePoints = layout.linePoints;\n      var targetTextWidth = void 0;\n\n      if (layout.labelAlignTo === 'edge') {\n        if (label.x < cx) {\n          targetTextWidth = linePoints[2][0] - layout.labelDistance - viewLeft - layout.edgeDistance;\n        } else {\n          targetTextWidth = viewLeft + viewWidth - layout.edgeDistance - linePoints[2][0] - layout.labelDistance;\n        }\n      } else if (layout.labelAlignTo === 'labelLine') {\n        if (label.x < cx) {\n          targetTextWidth = leftmostX - viewLeft - layout.bleedMargin;\n        } else {\n          targetTextWidth = viewLeft + viewWidth - rightmostX - layout.bleedMargin;\n        }\n      } else {\n        if (label.x < cx) {\n          targetTextWidth = label.x - viewLeft - layout.bleedMargin;\n        } else {\n          targetTextWidth = viewLeft + viewWidth - label.x - layout.bleedMargin;\n        }\n      }\n\n      layout.targetTextWidth = targetTextWidth;\n      constrainTextWidth(layout, targetTextWidth);\n    }\n  }\n\n  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);\n  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var layout = labelLayoutList[i];\n\n    if (!isPositionCenter(layout) && layout.linePoints) {\n      var label = layout.label;\n      var linePoints = layout.linePoints;\n      var isAlignToEdge = layout.labelAlignTo === 'edge';\n      var padding = label.style.padding;\n      var paddingH = padding ? padding[1] + padding[3] : 0; // textRect.width already contains paddingH if bgColor is set\n\n      var extraPaddingH = label.style.backgroundColor ? 0 : paddingH;\n      var realTextWidth = layout.rect.width + extraPaddingH;\n      var dist = linePoints[1][0] - linePoints[2][0];\n\n      if (isAlignToEdge) {\n        if (label.x < cx) {\n          linePoints[2][0] = viewLeft + layout.edgeDistance + realTextWidth + layout.labelDistance;\n        } else {\n          linePoints[2][0] = viewLeft + viewWidth - layout.edgeDistance - realTextWidth - layout.labelDistance;\n        }\n      } else {\n        if (label.x < cx) {\n          linePoints[2][0] = label.x + layout.labelDistance;\n        } else {\n          linePoints[2][0] = label.x - layout.labelDistance;\n        }\n\n        linePoints[1][0] = linePoints[2][0] + dist;\n      }\n\n      linePoints[1][1] = linePoints[2][1] = label.y;\n    }\n  }\n}\n/**\r\n * Set max width of each label, and then wrap each label to the max width.\r\n *\r\n * @param layout label layout\r\n * @param availableWidth max width for the label to display\r\n * @param forceRecalculate recaculate the text layout even if the current width\r\n * is smaller than `availableWidth`. This is useful when the text was previously\r\n * wrapped by calling `constrainTextWidth` but now `availableWidth` changed, in\r\n * which case, previous wrapping should be redo.\r\n */\n\n\nfunction constrainTextWidth(layout, availableWidth, forceRecalculate) {\n  if (forceRecalculate === void 0) {\n    forceRecalculate = false;\n  }\n\n  if (layout.labelStyleWidth != null) {\n    // User-defined style.width has the highest priority.\n    return;\n  }\n\n  var label = layout.label;\n  var style = label.style;\n  var textRect = layout.rect;\n  var bgColor = style.backgroundColor;\n  var padding = style.padding;\n  var paddingH = padding ? padding[1] + padding[3] : 0;\n  var overflow = style.overflow; // textRect.width already contains paddingH if bgColor is set\n\n  var oldOuterWidth = textRect.width + (bgColor ? 0 : paddingH);\n\n  if (availableWidth < oldOuterWidth || forceRecalculate) {\n    var oldHeight = textRect.height;\n\n    if (overflow && overflow.match('break')) {\n      // Temporarily set background to be null to calculate\n      // the bounding box without backgroud.\n      label.setStyle('backgroundColor', null); // Set constraining width\n\n      label.setStyle('width', availableWidth - paddingH); // This is the real bounding box of the text without padding\n\n      var innerRect = label.getBoundingRect();\n      label.setStyle('width', Math.ceil(innerRect.width));\n      label.setStyle('backgroundColor', bgColor);\n    } else {\n      var availableInnerWidth = availableWidth - paddingH;\n      var newWidth = availableWidth < oldOuterWidth // Current text is too wide, use `availableWidth` as max width.\n      ? availableInnerWidth : // Current available width is enough, but the text may have\n      // already been wrapped with a smaller available width.\n      forceRecalculate ? availableInnerWidth > layout.unconstrainedWidth // Current available is larger than text width,\n      // so don't constrain width (otherwise it may have\n      // empty space in the background).\n      ? null // Current available is smaller than text width, so\n      // use the current available width as constraining\n      // width.\n      : availableInnerWidth : // Current available width is enough, so no need to\n      // constrain.\n      null;\n      label.setStyle('width', newWidth);\n    }\n\n    var newRect = label.getBoundingRect();\n    textRect.width = newRect.width;\n    var margin = (label.style.margin || 0) + 2.1;\n    textRect.height = newRect.height + margin;\n    textRect.y -= (textRect.height - oldHeight) / 2;\n  }\n}\n\nfunction isPositionCenter(sectorShape) {\n  // Not change x for center label\n  return sectorShape.position === 'center';\n}\n\nexport default function pieLabelLayout(seriesModel) {\n  var data = seriesModel.getData();\n  var labelLayoutList = [];\n  var cx;\n  var cy;\n  var hasLabelRotate = false;\n  var minShowLabelRadian = (seriesModel.get('minShowLabelAngle') || 0) * RADIAN;\n  var viewRect = data.getLayout('viewRect');\n  var r = data.getLayout('r');\n  var viewWidth = viewRect.width;\n  var viewLeft = viewRect.x;\n  var viewTop = viewRect.y;\n  var viewHeight = viewRect.height;\n\n  function setNotShow(el) {\n    el.ignore = true;\n  }\n\n  function isLabelShown(label) {\n    if (!label.ignore) {\n      return true;\n    }\n\n    for (var key in label.states) {\n      if (label.states[key].ignore === false) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  data.each(function (idx) {\n    var sector = data.getItemGraphicEl(idx);\n    var sectorShape = sector.shape;\n    var label = sector.getTextContent();\n    var labelLine = sector.getTextGuideLine();\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis\n\n    var labelPosition = labelModel.get('position') || itemModel.get(['emphasis', 'label', 'position']);\n    var labelDistance = labelModel.get('distanceToLabelLine');\n    var labelAlignTo = labelModel.get('alignTo');\n    var edgeDistance = parsePercent(labelModel.get('edgeDistance'), viewWidth);\n    var bleedMargin = labelModel.get('bleedMargin');\n    var labelLineModel = itemModel.getModel('labelLine');\n    var labelLineLen = labelLineModel.get('length');\n    labelLineLen = parsePercent(labelLineLen, viewWidth);\n    var labelLineLen2 = labelLineModel.get('length2');\n    labelLineLen2 = parsePercent(labelLineLen2, viewWidth);\n\n    if (Math.abs(sectorShape.endAngle - sectorShape.startAngle) < minShowLabelRadian) {\n      each(label.states, setNotShow);\n      label.ignore = true;\n      return;\n    }\n\n    if (!isLabelShown(label)) {\n      return;\n    }\n\n    var midAngle = (sectorShape.startAngle + sectorShape.endAngle) / 2;\n    var nx = Math.cos(midAngle);\n    var ny = Math.sin(midAngle);\n    var textX;\n    var textY;\n    var linePoints;\n    var textAlign;\n    cx = sectorShape.cx;\n    cy = sectorShape.cy;\n    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\n    if (labelPosition === 'center') {\n      textX = sectorShape.cx;\n      textY = sectorShape.cy;\n      textAlign = 'center';\n    } else {\n      var x1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * nx : sectorShape.r * nx) + cx;\n      var y1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * ny : sectorShape.r * ny) + cy;\n      textX = x1 + nx * 3;\n      textY = y1 + ny * 3;\n\n      if (!isLabelInside) {\n        // For roseType\n        var x2 = x1 + nx * (labelLineLen + r - sectorShape.r);\n        var y2 = y1 + ny * (labelLineLen + r - sectorShape.r);\n        var x3 = x2 + (nx < 0 ? -1 : 1) * labelLineLen2;\n        var y3 = y2;\n\n        if (labelAlignTo === 'edge') {\n          // Adjust textX because text align of edge is opposite\n          textX = nx < 0 ? viewLeft + edgeDistance : viewLeft + viewWidth - edgeDistance;\n        } else {\n          textX = x3 + (nx < 0 ? -labelDistance : labelDistance);\n        }\n\n        textY = y3;\n        linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n      }\n\n      textAlign = isLabelInside ? 'center' : labelAlignTo === 'edge' ? nx > 0 ? 'right' : 'left' : nx > 0 ? 'left' : 'right';\n    }\n\n    var PI = Math.PI;\n    var labelRotate = 0;\n    var rotate = labelModel.get('rotate');\n\n    if (isNumber(rotate)) {\n      labelRotate = rotate * (PI / 180);\n    } else if (labelPosition === 'center') {\n      labelRotate = 0;\n    } else if (rotate === 'radial' || rotate === true) {\n      var radialAngle = nx < 0 ? -midAngle + PI : -midAngle;\n      labelRotate = radialAngle;\n    } else if (rotate === 'tangential' && labelPosition !== 'outside' && labelPosition !== 'outer') {\n      var rad = Math.atan2(nx, ny);\n\n      if (rad < 0) {\n        rad = PI * 2 + rad;\n      }\n\n      var isDown = ny > 0;\n\n      if (isDown) {\n        rad = PI + rad;\n      }\n\n      labelRotate = rad - PI;\n    }\n\n    hasLabelRotate = !!labelRotate;\n    label.x = textX;\n    label.y = textY;\n    label.rotation = labelRotate;\n    label.setStyle({\n      verticalAlign: 'middle'\n    }); // Not sectorShape the inside label\n\n    if (!isLabelInside) {\n      var textRect = label.getBoundingRect().clone();\n      textRect.applyTransform(label.getComputedTransform()); // Text has a default 1px stroke. Exclude this.\n\n      var margin = (label.style.margin || 0) + 2.1;\n      textRect.y -= margin / 2;\n      textRect.height += margin;\n      labelLayoutList.push({\n        label: label,\n        labelLine: labelLine,\n        position: labelPosition,\n        len: labelLineLen,\n        len2: labelLineLen2,\n        minTurnAngle: labelLineModel.get('minTurnAngle'),\n        maxSurfaceAngle: labelLineModel.get('maxSurfaceAngle'),\n        surfaceNormal: new Point(nx, ny),\n        linePoints: linePoints,\n        textAlign: textAlign,\n        labelDistance: labelDistance,\n        labelAlignTo: labelAlignTo,\n        edgeDistance: edgeDistance,\n        bleedMargin: bleedMargin,\n        rect: textRect,\n        unconstrainedWidth: textRect.width,\n        labelStyleWidth: label.style.width\n      });\n    } else {\n      label.setStyle({\n        align: textAlign\n      });\n      var selectState = label.states.select;\n\n      if (selectState) {\n        selectState.x += label.x;\n        selectState.y += label.y;\n      }\n    }\n\n    sector.setTextConfig({\n      inside: isLabelInside\n    });\n  });\n\n  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);\n  }\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var layout = labelLayoutList[i];\n    var label = layout.label;\n    var labelLine = layout.labelLine;\n    var notShowLabel = isNaN(label.x) || isNaN(label.y);\n\n    if (label) {\n      label.setStyle({\n        align: layout.textAlign\n      });\n\n      if (notShowLabel) {\n        each(label.states, setNotShow);\n        label.ignore = true;\n      }\n\n      var selectState = label.states.select;\n\n      if (selectState) {\n        selectState.x += label.x;\n        selectState.y += label.y;\n      }\n    }\n\n    if (labelLine) {\n      var linePoints = layout.linePoints;\n\n      if (notShowLabel || !linePoints) {\n        each(labelLine.states, setNotShow);\n        labelLine.ignore = true;\n      } else {\n        limitTurnAngle(linePoints, layout.minTurnAngle);\n        limitSurfaceAngle(linePoints, layout.surfaceNormal, layout.maxSurfaceAngle);\n        labelLine.setShape({\n          points: linePoints\n        }); // Set the anchor to the midpoint of sector\n\n        label.__hostTarget.textGuideLineConfig = {\n          anchor: new Point(linePoints[0][0], linePoints[0][1])\n        };\n      }\n    }\n  }\n}"]},"metadata":{},"sourceType":"module"}