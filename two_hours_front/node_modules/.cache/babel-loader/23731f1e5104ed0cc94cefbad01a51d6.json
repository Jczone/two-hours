{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array.join.js\";\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport { createHashMap, isObject, retrieve2 } from 'zrender/lib/core/util.js';\nimport { makeInner } from '../../util/model.js';\nimport { shouldRetrieveDataByName } from '../Source.js';\nvar inner = makeInner();\nvar dimTypeShort = {\n  float: 'f',\n  int: 'i',\n  ordinal: 'o',\n  number: 'n',\n  time: 't'\n};\n/**\r\n * Represents the dimension requirement of a series.\r\n *\r\n * NOTICE:\r\n * When there are too many dimensions in dataset and many series, only the used dimensions\r\n * (i.e., used by coord sys and declared in `series.encode`) are add to `dimensionDefineList`.\r\n * But users may query data by other unused dimension names.\r\n * In this case, users can only query data if and only if they have defined dimension names\r\n * via ec option, so we provide `getDimensionIndexFromSource`, which only query them from\r\n * `source` dimensions.\r\n */\n\nvar SeriesDataSchema =\n/** @class */\nfunction () {\n  function SeriesDataSchema(opt) {\n    this.dimensions = opt.dimensions;\n    this._dimOmitted = opt.dimensionOmitted;\n    this.source = opt.source;\n    this._fullDimCount = opt.fullDimensionCount;\n\n    this._updateDimOmitted(opt.dimensionOmitted);\n  }\n\n  SeriesDataSchema.prototype.isDimensionOmitted = function () {\n    return this._dimOmitted;\n  };\n\n  SeriesDataSchema.prototype._updateDimOmitted = function (dimensionOmitted) {\n    this._dimOmitted = dimensionOmitted;\n\n    if (!dimensionOmitted) {\n      return;\n    }\n\n    if (!this._dimNameMap) {\n      this._dimNameMap = ensureSourceDimNameMap(this.source);\n    }\n  };\n  /**\r\n   * @caution Can only be used when `dimensionOmitted: true`.\r\n   *\r\n   * Get index by user defined dimension name (i.e., not internal generate name).\r\n   * That is, get index from `dimensionsDefine`.\r\n   * If no `dimensionsDefine`, or no name get, return -1.\r\n   */\n\n\n  SeriesDataSchema.prototype.getSourceDimensionIndex = function (dimName) {\n    return retrieve2(this._dimNameMap.get(dimName), -1);\n  };\n  /**\r\n   * @caution Can only be used when `dimensionOmitted: true`.\r\n   *\r\n   * Notice: may return `null`/`undefined` if user not specify dimension names.\r\n   */\n\n\n  SeriesDataSchema.prototype.getSourceDimension = function (dimIndex) {\n    var dimensionsDefine = this.source.dimensionsDefine;\n\n    if (dimensionsDefine) {\n      return dimensionsDefine[dimIndex];\n    }\n  };\n\n  SeriesDataSchema.prototype.makeStoreSchema = function () {\n    var dimCount = this._fullDimCount;\n    var willRetrieveDataByName = shouldRetrieveDataByName(this.source);\n    var makeHashStrict = !shouldOmitUnusedDimensions(dimCount); // If source don't have dimensions or series don't omit unsed dimensions.\n    // Generate from seriesDimList directly\n\n    var dimHash = '';\n    var dims = [];\n\n    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < dimCount; fullDimIdx++) {\n      var property = void 0;\n      var type = void 0;\n      var ordinalMeta = void 0;\n      var seriesDimDef = this.dimensions[seriesDimIdx]; // The list has been sorted by `storeDimIndex` asc.\n\n      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {\n        property = willRetrieveDataByName ? seriesDimDef.name : null;\n        type = seriesDimDef.type;\n        ordinalMeta = seriesDimDef.ordinalMeta;\n        seriesDimIdx++;\n      } else {\n        var sourceDimDef = this.getSourceDimension(fullDimIdx);\n\n        if (sourceDimDef) {\n          property = willRetrieveDataByName ? sourceDimDef.name : null;\n          type = sourceDimDef.type;\n        }\n      }\n\n      dims.push({\n        property: property,\n        type: type,\n        ordinalMeta: ordinalMeta\n      }); // If retrieving data by index,\n      //   use <index, type, ordinalMeta> to determine whether data can be shared.\n      //   (Becuase in this case there might be no dimension name defined in dataset, but indices always exists).\n      //   (indices are always 0, 1, 2, ..., so we can ignore them to shorten the hash).\n      // Otherwise if retrieving data by property name (like `data: [{aa: 123, bb: 765}, ...]`),\n      //   use <property, type, ordinalMeta> in hash.\n\n      if (willRetrieveDataByName && property != null // For data stack, we have make sure each series has its own dim on this store.\n      // So we do not add property to hash to make sure they can share this store.\n      && (!seriesDimDef || !seriesDimDef.isCalculationCoord)) {\n        dimHash += makeHashStrict // Use escape character '`' in case that property name contains '$'.\n        ? property.replace(/\\`/g, '`1').replace(/\\$/g, '`2') // For better performance, when there are large dimensions, tolerant this defects that hardly meet.\n        : property;\n      }\n\n      dimHash += '$';\n      dimHash += dimTypeShort[type] || 'f';\n\n      if (ordinalMeta) {\n        dimHash += ordinalMeta.uid;\n      }\n\n      dimHash += '$';\n    } // Source from endpoint(usually series) will be read differently\n    // when seriesLayoutBy or startIndex(which is affected by sourceHeader) are different.\n    // So we use this three props as key.\n\n\n    var source = this.source;\n    var hash = [source.seriesLayoutBy, source.startIndex, dimHash].join('$$');\n    return {\n      dimensions: dims,\n      hash: hash\n    };\n  };\n\n  SeriesDataSchema.prototype.makeOutputDimensionNames = function () {\n    var result = [];\n\n    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < this._fullDimCount; fullDimIdx++) {\n      var name_1 = void 0;\n      var seriesDimDef = this.dimensions[seriesDimIdx]; // The list has been sorted by `storeDimIndex` asc.\n\n      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {\n        if (!seriesDimDef.isCalculationCoord) {\n          name_1 = seriesDimDef.name;\n        }\n\n        seriesDimIdx++;\n      } else {\n        var sourceDimDef = this.getSourceDimension(fullDimIdx);\n\n        if (sourceDimDef) {\n          name_1 = sourceDimDef.name;\n        }\n      }\n\n      result.push(name_1);\n    }\n\n    return result;\n  };\n\n  SeriesDataSchema.prototype.appendCalculationDimension = function (dimDef) {\n    this.dimensions.push(dimDef);\n    dimDef.isCalculationCoord = true;\n    this._fullDimCount++; // If append dimension on a data store, consider the store\n    // might be shared by different series, series dimensions not\n    // really map to store dimensions.\n\n    this._updateDimOmitted(true);\n  };\n\n  return SeriesDataSchema;\n}();\n\nexport { SeriesDataSchema };\nexport function isSeriesDataSchema(schema) {\n  return schema instanceof SeriesDataSchema;\n}\nexport function createDimNameMap(dimsDef) {\n  var dataDimNameMap = createHashMap();\n\n  for (var i = 0; i < (dimsDef || []).length; i++) {\n    var dimDefItemRaw = dimsDef[i];\n    var userDimName = isObject(dimDefItemRaw) ? dimDefItemRaw.name : dimDefItemRaw;\n\n    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n      dataDimNameMap.set(userDimName, i);\n    }\n  }\n\n  return dataDimNameMap;\n}\nexport function ensureSourceDimNameMap(source) {\n  var innerSource = inner(source);\n  return innerSource.dimNameMap || (innerSource.dimNameMap = createDimNameMap(source.dimensionsDefine));\n}\nexport function shouldOmitUnusedDimensions(dimCount) {\n  return dimCount > 30;\n}","map":{"version":3,"sources":["F:/Desktop/繁星教育/TH资料/two_hours_front/node_modules/echarts/lib/data/helper/SeriesDataSchema.js"],"names":["createHashMap","isObject","retrieve2","makeInner","shouldRetrieveDataByName","inner","dimTypeShort","float","int","ordinal","number","time","SeriesDataSchema","opt","dimensions","_dimOmitted","dimensionOmitted","source","_fullDimCount","fullDimensionCount","_updateDimOmitted","prototype","isDimensionOmitted","_dimNameMap","ensureSourceDimNameMap","getSourceDimensionIndex","dimName","get","getSourceDimension","dimIndex","dimensionsDefine","makeStoreSchema","dimCount","willRetrieveDataByName","makeHashStrict","shouldOmitUnusedDimensions","dimHash","dims","fullDimIdx","seriesDimIdx","property","type","ordinalMeta","seriesDimDef","storeDimIndex","name","sourceDimDef","push","isCalculationCoord","replace","uid","hash","seriesLayoutBy","startIndex","join","makeOutputDimensionNames","result","name_1","appendCalculationDimension","dimDef","isSeriesDataSchema","schema","createDimNameMap","dimsDef","dataDimNameMap","i","length","dimDefItemRaw","userDimName","set","innerSource","dimNameMap"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport { createHashMap, isObject, retrieve2 } from 'zrender/lib/core/util.js';\nimport { makeInner } from '../../util/model.js';\nimport { shouldRetrieveDataByName } from '../Source.js';\nvar inner = makeInner();\nvar dimTypeShort = {\n  float: 'f',\n  int: 'i',\n  ordinal: 'o',\n  number: 'n',\n  time: 't'\n};\n/**\r\n * Represents the dimension requirement of a series.\r\n *\r\n * NOTICE:\r\n * When there are too many dimensions in dataset and many series, only the used dimensions\r\n * (i.e., used by coord sys and declared in `series.encode`) are add to `dimensionDefineList`.\r\n * But users may query data by other unused dimension names.\r\n * In this case, users can only query data if and only if they have defined dimension names\r\n * via ec option, so we provide `getDimensionIndexFromSource`, which only query them from\r\n * `source` dimensions.\r\n */\n\nvar SeriesDataSchema =\n/** @class */\nfunction () {\n  function SeriesDataSchema(opt) {\n    this.dimensions = opt.dimensions;\n    this._dimOmitted = opt.dimensionOmitted;\n    this.source = opt.source;\n    this._fullDimCount = opt.fullDimensionCount;\n\n    this._updateDimOmitted(opt.dimensionOmitted);\n  }\n\n  SeriesDataSchema.prototype.isDimensionOmitted = function () {\n    return this._dimOmitted;\n  };\n\n  SeriesDataSchema.prototype._updateDimOmitted = function (dimensionOmitted) {\n    this._dimOmitted = dimensionOmitted;\n\n    if (!dimensionOmitted) {\n      return;\n    }\n\n    if (!this._dimNameMap) {\n      this._dimNameMap = ensureSourceDimNameMap(this.source);\n    }\n  };\n  /**\r\n   * @caution Can only be used when `dimensionOmitted: true`.\r\n   *\r\n   * Get index by user defined dimension name (i.e., not internal generate name).\r\n   * That is, get index from `dimensionsDefine`.\r\n   * If no `dimensionsDefine`, or no name get, return -1.\r\n   */\n\n\n  SeriesDataSchema.prototype.getSourceDimensionIndex = function (dimName) {\n    return retrieve2(this._dimNameMap.get(dimName), -1);\n  };\n  /**\r\n   * @caution Can only be used when `dimensionOmitted: true`.\r\n   *\r\n   * Notice: may return `null`/`undefined` if user not specify dimension names.\r\n   */\n\n\n  SeriesDataSchema.prototype.getSourceDimension = function (dimIndex) {\n    var dimensionsDefine = this.source.dimensionsDefine;\n\n    if (dimensionsDefine) {\n      return dimensionsDefine[dimIndex];\n    }\n  };\n\n  SeriesDataSchema.prototype.makeStoreSchema = function () {\n    var dimCount = this._fullDimCount;\n    var willRetrieveDataByName = shouldRetrieveDataByName(this.source);\n    var makeHashStrict = !shouldOmitUnusedDimensions(dimCount); // If source don't have dimensions or series don't omit unsed dimensions.\n    // Generate from seriesDimList directly\n\n    var dimHash = '';\n    var dims = [];\n\n    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < dimCount; fullDimIdx++) {\n      var property = void 0;\n      var type = void 0;\n      var ordinalMeta = void 0;\n      var seriesDimDef = this.dimensions[seriesDimIdx]; // The list has been sorted by `storeDimIndex` asc.\n\n      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {\n        property = willRetrieveDataByName ? seriesDimDef.name : null;\n        type = seriesDimDef.type;\n        ordinalMeta = seriesDimDef.ordinalMeta;\n        seriesDimIdx++;\n      } else {\n        var sourceDimDef = this.getSourceDimension(fullDimIdx);\n\n        if (sourceDimDef) {\n          property = willRetrieveDataByName ? sourceDimDef.name : null;\n          type = sourceDimDef.type;\n        }\n      }\n\n      dims.push({\n        property: property,\n        type: type,\n        ordinalMeta: ordinalMeta\n      }); // If retrieving data by index,\n      //   use <index, type, ordinalMeta> to determine whether data can be shared.\n      //   (Becuase in this case there might be no dimension name defined in dataset, but indices always exists).\n      //   (indices are always 0, 1, 2, ..., so we can ignore them to shorten the hash).\n      // Otherwise if retrieving data by property name (like `data: [{aa: 123, bb: 765}, ...]`),\n      //   use <property, type, ordinalMeta> in hash.\n\n      if (willRetrieveDataByName && property != null // For data stack, we have make sure each series has its own dim on this store.\n      // So we do not add property to hash to make sure they can share this store.\n      && (!seriesDimDef || !seriesDimDef.isCalculationCoord)) {\n        dimHash += makeHashStrict // Use escape character '`' in case that property name contains '$'.\n        ? property.replace(/\\`/g, '`1').replace(/\\$/g, '`2') // For better performance, when there are large dimensions, tolerant this defects that hardly meet.\n        : property;\n      }\n\n      dimHash += '$';\n      dimHash += dimTypeShort[type] || 'f';\n\n      if (ordinalMeta) {\n        dimHash += ordinalMeta.uid;\n      }\n\n      dimHash += '$';\n    } // Source from endpoint(usually series) will be read differently\n    // when seriesLayoutBy or startIndex(which is affected by sourceHeader) are different.\n    // So we use this three props as key.\n\n\n    var source = this.source;\n    var hash = [source.seriesLayoutBy, source.startIndex, dimHash].join('$$');\n    return {\n      dimensions: dims,\n      hash: hash\n    };\n  };\n\n  SeriesDataSchema.prototype.makeOutputDimensionNames = function () {\n    var result = [];\n\n    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < this._fullDimCount; fullDimIdx++) {\n      var name_1 = void 0;\n      var seriesDimDef = this.dimensions[seriesDimIdx]; // The list has been sorted by `storeDimIndex` asc.\n\n      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {\n        if (!seriesDimDef.isCalculationCoord) {\n          name_1 = seriesDimDef.name;\n        }\n\n        seriesDimIdx++;\n      } else {\n        var sourceDimDef = this.getSourceDimension(fullDimIdx);\n\n        if (sourceDimDef) {\n          name_1 = sourceDimDef.name;\n        }\n      }\n\n      result.push(name_1);\n    }\n\n    return result;\n  };\n\n  SeriesDataSchema.prototype.appendCalculationDimension = function (dimDef) {\n    this.dimensions.push(dimDef);\n    dimDef.isCalculationCoord = true;\n    this._fullDimCount++; // If append dimension on a data store, consider the store\n    // might be shared by different series, series dimensions not\n    // really map to store dimensions.\n\n    this._updateDimOmitted(true);\n  };\n\n  return SeriesDataSchema;\n}();\n\nexport { SeriesDataSchema };\nexport function isSeriesDataSchema(schema) {\n  return schema instanceof SeriesDataSchema;\n}\nexport function createDimNameMap(dimsDef) {\n  var dataDimNameMap = createHashMap();\n\n  for (var i = 0; i < (dimsDef || []).length; i++) {\n    var dimDefItemRaw = dimsDef[i];\n    var userDimName = isObject(dimDefItemRaw) ? dimDefItemRaw.name : dimDefItemRaw;\n\n    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n      dataDimNameMap.set(userDimName, i);\n    }\n  }\n\n  return dataDimNameMap;\n}\nexport function ensureSourceDimNameMap(source) {\n  var innerSource = inner(source);\n  return innerSource.dimNameMap || (innerSource.dimNameMap = createDimNameMap(source.dimensionsDefine));\n}\nexport function shouldOmitUnusedDimensions(dimCount) {\n  return dimCount > 30;\n}"]},"metadata":{},"sourceType":"module"}