{"ast":null,"code":"import \"core-js/modules/es.array.sort.js\";\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport { each, defaults, keys } from 'zrender/lib/core/util.js';\nimport { parsePercent } from '../util/number.js';\nimport { isDimensionStacked } from '../data/helper/dataStackHelper.js';\nimport createRenderPlanner from '../chart/helper/createRenderPlanner.js';\nimport { createFloat32Array } from '../util/vendor.js';\nvar STACK_PREFIX = '__ec_stack_';\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n/**\r\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\r\n */\n\n\nexport function getLayoutOnAxis(opt) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n\n  var bandWidth = baseAxis.getBandWidth();\n\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n\n  var widthAndOffsets = doCalBarWidthAndOffset(params);\n  var result = [];\n\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n\n  return result;\n}\nexport function prepareLayoutBarSeries(seriesType, ecModel) {\n  var seriesModels = [];\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for cartesian2d only\n    if (isOnCartesian(seriesModel)) {\n      seriesModels.push(seriesModel);\n    }\n  });\n  return seriesModels;\n}\n/**\r\n * Map from (baseAxis.dim + '_' + baseAxis.index) to min gap of two adjacent\r\n * values.\r\n * This works for time axes, value axes, and log axes.\r\n * For a single time axis, return value is in the form like\r\n * {'x_0': [1000000]}.\r\n * The value of 1000000 is in milliseconds.\r\n */\n\nfunction getValueAxesMinGaps(barSeries) {\n  /**\r\n   * Map from axis.index to values.\r\n   * For a single time axis, axisValues is in the form like\r\n   * {'x_0': [1495555200000, 1495641600000, 1495728000000]}.\r\n   * Items in axisValues[x], e.g. 1495555200000, are time values of all\r\n   * series.\r\n   */\n  var axisValues = {};\n  each(barSeries, function (seriesModel) {\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n\n    if (baseAxis.type !== 'time' && baseAxis.type !== 'value') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var key = baseAxis.dim + '_' + baseAxis.index;\n    var dimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));\n    var store = data.getStore();\n\n    for (var i = 0, cnt = store.count(); i < cnt; ++i) {\n      var value = store.get(dimIdx, i);\n\n      if (!axisValues[key]) {\n        // No previous data for the axis\n        axisValues[key] = [value];\n      } else {\n        // No value in previous series\n        axisValues[key].push(value);\n      } // Ignore duplicated time values in the same axis\n\n    }\n  });\n  var axisMinGaps = {};\n\n  for (var key in axisValues) {\n    if (axisValues.hasOwnProperty(key)) {\n      var valuesInAxis = axisValues[key];\n\n      if (valuesInAxis) {\n        // Sort axis values into ascending order to calculate gaps\n        valuesInAxis.sort(function (a, b) {\n          return a - b;\n        });\n        var min = null;\n\n        for (var j = 1; j < valuesInAxis.length; ++j) {\n          var delta = valuesInAxis[j] - valuesInAxis[j - 1];\n\n          if (delta > 0) {\n            // Ignore 0 delta because they are of the same axis value\n            min = min === null ? delta : Math.min(min, delta);\n          }\n        } // Set to null if only have one data\n\n\n        axisMinGaps[key] = min;\n      }\n    }\n  }\n\n  return axisMinGaps;\n}\n\nexport function makeColumnLayout(barSeries) {\n  var axisMinGaps = getValueAxesMinGaps(barSeries);\n  var seriesInfoList = [];\n  each(barSeries, function (seriesModel) {\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth;\n\n    if (baseAxis.type === 'category') {\n      bandWidth = baseAxis.getBandWidth();\n    } else if (baseAxis.type === 'value' || baseAxis.type === 'time') {\n      var key = baseAxis.dim + '_' + baseAxis.index;\n      var minGap = axisMinGaps[key];\n      var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);\n      var scale = baseAxis.scale.getExtent();\n      var scaleSpan = Math.abs(scale[1] - scale[0]);\n      bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan; // When there is only one data value\n    } else {\n      var data = seriesModel.getData();\n      bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    }\n\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barMinWidth = parsePercent( // barMinWidth by default is 0.5 / 1 in cartesian. Because in value axis,\n    // the auto-calculated bar width might be less than 0.5 / 1.\n    seriesModel.get('barMinWidth') || (isInLargeMode(seriesModel) ? 0.5 : 1), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    seriesInfoList.push({\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barMinWidth: barMinWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    });\n  });\n  return doCalBarWidthAndOffset(seriesInfoList);\n}\n\nfunction doCalBarWidthAndOffset(seriesInfoList) {\n  // Columns info on each category axis. Key is cartesian name\n  var columnsMap = {};\n  each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: null,\n      gap: '20%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    }; // Caution: In a single coordinate system, these barGrid attributes\n    // will be shared by series. Consider that they have default values,\n    // only the attributes set on the last series will work.\n    // Do not change this fact unless there will be a break change.\n\n    var barWidth = seriesInfo.barWidth;\n\n    if (barWidth && !stacks[stackId].width) {\n      // See #6312, do not restrict width.\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barMinWidth = seriesInfo.barMinWidth;\n    barMinWidth && (stacks[stackId].minWidth = barMinWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGapPercent = columnsOnAxis.categoryGap;\n\n    if (categoryGapPercent == null) {\n      var columnCount = keys(stacks).length; // More columns in one group\n      // the spaces between group is smaller. Or the column will be too thin.\n\n      categoryGapPercent = Math.max(35 - columnCount * 4, 15) + '%';\n    }\n\n    var categoryGap = parsePercent(categoryGapPercent, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    each(stacks, function (column) {\n      var maxWidth = column.maxWidth;\n      var minWidth = column.minWidth;\n\n      if (!column.width) {\n        var finalWidth = autoWidth;\n\n        if (maxWidth && maxWidth < finalWidth) {\n          finalWidth = Math.min(maxWidth, remainedWidth);\n        } // `minWidth` has higher priority. `minWidth` decide that wheter the\n        // bar is able to be visible. So `minWidth` should not be restricted\n        // by `maxWidth` or `remainedWidth` (which is from `bandWidth`). In\n        // the extreme cases for `value` axis, bars are allowed to overlap\n        // with each other if `minWidth` specified.\n\n\n        if (minWidth && minWidth > finalWidth) {\n          finalWidth = minWidth;\n        }\n\n        if (finalWidth !== autoWidth) {\n          column.width = finalWidth;\n          remainedWidth -= finalWidth + barGapPercent * finalWidth;\n          autoWidthCount--;\n        }\n      } else {\n        // `barMinWidth/barMaxWidth` has higher priority than `barWidth`, as\n        // CSS does. Becuase barWidth can be a percent value, where\n        // `barMaxWidth` can be used to restrict the final width.\n        var finalWidth = column.width;\n\n        if (maxWidth) {\n          finalWidth = Math.min(finalWidth, maxWidth);\n        } // `minWidth` has higher priority, as described above\n\n\n        if (minWidth) {\n          finalWidth = Math.max(finalWidth, minWidth);\n        }\n\n        column.width = finalWidth;\n        remainedWidth -= finalWidth + barGapPercent * finalWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        bandWidth: bandWidth,\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n\nfunction retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {\n  if (barWidthAndOffset && axis) {\n    var result = barWidthAndOffset[getAxisKey(axis)];\n\n    if (result != null && seriesModel != null) {\n      return result[getSeriesStackId(seriesModel)];\n    }\n\n    return result;\n  }\n}\n\nexport { retrieveColumnLayout };\nexport function layout(seriesType, ecModel) {\n  var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);\n  var barWidthAndOffset = makeColumnLayout(seriesModels);\n  each(seriesModels, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    data.setLayout({\n      bandWidth: columnLayoutInfo.bandWidth,\n      offset: columnOffset,\n      size: columnWidth\n    });\n  });\n} // TODO: Do not support stack in large mode yet.\n\nexport function createProgressiveLayout(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function reset(seriesModel) {\n      if (!isOnCartesian(seriesModel)) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      var cartesian = seriesModel.coordinateSystem;\n      var baseAxis = cartesian.getBaseAxis();\n      var valueAxis = cartesian.getOtherAxis(baseAxis);\n      var valueDimIdx = data.getDimensionIndex(data.mapDimension(valueAxis.dim));\n      var baseDimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));\n      var drawBackground = seriesModel.get('showBackground', true);\n      var valueDim = data.mapDimension(valueAxis.dim);\n      var stackResultDim = data.getCalculationInfo('stackResultDimension');\n      var stacked = isDimensionStacked(data, valueDim) && !!data.getCalculationInfo('stackedOnSeries');\n      var isValueAxisH = valueAxis.isHorizontal();\n      var valueAxisStart = getValueAxisStart(baseAxis, valueAxis);\n      var isLarge = isInLargeMode(seriesModel);\n      var barMinHeight = seriesModel.get('barMinHeight') || 0;\n      var stackedDimIdx = stackResultDim && data.getDimensionIndex(stackResultDim); // Layout info.\n\n      var columnWidth = data.getLayout('size');\n      var columnOffset = data.getLayout('offset');\n      return {\n        progress: function progress(params, data) {\n          var count = params.count;\n          var largePoints = isLarge && createFloat32Array(count * 3);\n          var largeBackgroundPoints = isLarge && drawBackground && createFloat32Array(count * 3);\n          var largeDataIndices = isLarge && createFloat32Array(count);\n          var coordLayout = cartesian.master.getRect();\n          var bgSize = isValueAxisH ? coordLayout.width : coordLayout.height;\n          var dataIndex;\n          var store = data.getStore();\n          var idxOffset = 0;\n\n          while ((dataIndex = params.next()) != null) {\n            var value = store.get(stacked ? stackedDimIdx : valueDimIdx, dataIndex);\n            var baseValue = store.get(baseDimIdx, dataIndex);\n            var baseCoord = valueAxisStart;\n            var startValue = void 0; // Because of the barMinHeight, we can not use the value in\n            // stackResultDimension directly.\n\n            if (stacked) {\n              startValue = +value - store.get(valueDimIdx, dataIndex);\n            }\n\n            var x = void 0;\n            var y = void 0;\n            var width = void 0;\n            var height = void 0;\n\n            if (isValueAxisH) {\n              var coord = cartesian.dataToPoint([value, baseValue]);\n\n              if (stacked) {\n                var startCoord = cartesian.dataToPoint([startValue, baseValue]);\n                baseCoord = startCoord[0];\n              }\n\n              x = baseCoord;\n              y = coord[1] + columnOffset;\n              width = coord[0] - baseCoord;\n              height = columnWidth;\n\n              if (Math.abs(width) < barMinHeight) {\n                width = (width < 0 ? -1 : 1) * barMinHeight;\n              }\n            } else {\n              var coord = cartesian.dataToPoint([baseValue, value]);\n\n              if (stacked) {\n                var startCoord = cartesian.dataToPoint([baseValue, startValue]);\n                baseCoord = startCoord[1];\n              }\n\n              x = coord[0] + columnOffset;\n              y = baseCoord;\n              width = columnWidth;\n              height = coord[1] - baseCoord;\n\n              if (Math.abs(height) < barMinHeight) {\n                // Include zero to has a positive bar\n                height = (height <= 0 ? -1 : 1) * barMinHeight;\n              }\n            }\n\n            if (!isLarge) {\n              data.setItemLayout(dataIndex, {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n              });\n            } else {\n              largePoints[idxOffset] = x;\n              largePoints[idxOffset + 1] = y;\n              largePoints[idxOffset + 2] = isValueAxisH ? width : height;\n\n              if (largeBackgroundPoints) {\n                largeBackgroundPoints[idxOffset] = isValueAxisH ? coordLayout.x : x;\n                largeBackgroundPoints[idxOffset + 1] = isValueAxisH ? y : coordLayout.y;\n                largeBackgroundPoints[idxOffset + 2] = bgSize;\n              }\n\n              largeDataIndices[dataIndex] = dataIndex;\n            }\n\n            idxOffset += 3;\n          }\n\n          if (isLarge) {\n            data.setLayout({\n              largePoints: largePoints,\n              largeDataIndices: largeDataIndices,\n              largeBackgroundPoints: largeBackgroundPoints,\n              valueAxisHorizontal: isValueAxisH\n            });\n          }\n        }\n      };\n    }\n  };\n}\n\nfunction isOnCartesian(seriesModel) {\n  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n}\n\nfunction isInLargeMode(seriesModel) {\n  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;\n} // See cases in `test/bar-start.html` and `#7412`, `#8747`.\n\n\nfunction getValueAxisStart(baseAxis, valueAxis) {\n  return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === 'log' ? 1 : 0));\n}","map":{"version":3,"sources":["F:/Desktop/繁星教育/TH资料/two_hours_front/node_modules/echarts/lib/layout/barGrid.js"],"names":["each","defaults","keys","parsePercent","isDimensionStacked","createRenderPlanner","createFloat32Array","STACK_PREFIX","getSeriesStackId","seriesModel","get","seriesIndex","getAxisKey","axis","dim","index","getLayoutOnAxis","opt","params","baseAxis","axisKey","type","bandWidth","getBandWidth","i","count","push","stackId","widthAndOffsets","doCalBarWidthAndOffset","result","item","offsetCenter","offset","width","prepareLayoutBarSeries","seriesType","ecModel","seriesModels","eachSeriesByType","isOnCartesian","getValueAxesMinGaps","barSeries","axisValues","cartesian","coordinateSystem","getBaseAxis","data","getData","key","dimIdx","getDimensionIndex","mapDimension","store","getStore","cnt","value","axisMinGaps","hasOwnProperty","valuesInAxis","sort","a","b","min","j","length","delta","Math","makeColumnLayout","seriesInfoList","axisExtent","getExtent","minGap","extentSpan","abs","scale","scaleSpan","barWidth","barMaxWidth","barMinWidth","isInLargeMode","barGap","barCategoryGap","columnsMap","seriesInfo","idx","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","gap","stacks","maxWidth","minWidth","coordSysName","categoryGapPercent","columnCount","max","barGapPercent","autoWidth","column","finalWidth","widthSum","lastColumn","retrieveColumnLayout","barWidthAndOffset","layout","columnLayoutInfo","columnOffset","columnWidth","setLayout","size","createProgressiveLayout","plan","reset","valueAxis","getOtherAxis","valueDimIdx","baseDimIdx","drawBackground","valueDim","stackResultDim","getCalculationInfo","stacked","isValueAxisH","isHorizontal","valueAxisStart","getValueAxisStart","isLarge","barMinHeight","stackedDimIdx","getLayout","progress","largePoints","largeBackgroundPoints","largeDataIndices","coordLayout","master","getRect","bgSize","height","dataIndex","idxOffset","next","baseValue","baseCoord","startValue","x","y","coord","dataToPoint","startCoord","setItemLayout","valueAxisHorizontal","pipelineContext","large","toGlobalCoord","dataToCoord"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport { each, defaults, keys } from 'zrender/lib/core/util.js';\nimport { parsePercent } from '../util/number.js';\nimport { isDimensionStacked } from '../data/helper/dataStackHelper.js';\nimport createRenderPlanner from '../chart/helper/createRenderPlanner.js';\nimport { createFloat32Array } from '../util/vendor.js';\nvar STACK_PREFIX = '__ec_stack_';\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n/**\r\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\r\n */\n\n\nexport function getLayoutOnAxis(opt) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n\n  var bandWidth = baseAxis.getBandWidth();\n\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n\n  var widthAndOffsets = doCalBarWidthAndOffset(params);\n  var result = [];\n\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n\n  return result;\n}\nexport function prepareLayoutBarSeries(seriesType, ecModel) {\n  var seriesModels = [];\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for cartesian2d only\n    if (isOnCartesian(seriesModel)) {\n      seriesModels.push(seriesModel);\n    }\n  });\n  return seriesModels;\n}\n/**\r\n * Map from (baseAxis.dim + '_' + baseAxis.index) to min gap of two adjacent\r\n * values.\r\n * This works for time axes, value axes, and log axes.\r\n * For a single time axis, return value is in the form like\r\n * {'x_0': [1000000]}.\r\n * The value of 1000000 is in milliseconds.\r\n */\n\nfunction getValueAxesMinGaps(barSeries) {\n  /**\r\n   * Map from axis.index to values.\r\n   * For a single time axis, axisValues is in the form like\r\n   * {'x_0': [1495555200000, 1495641600000, 1495728000000]}.\r\n   * Items in axisValues[x], e.g. 1495555200000, are time values of all\r\n   * series.\r\n   */\n  var axisValues = {};\n  each(barSeries, function (seriesModel) {\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n\n    if (baseAxis.type !== 'time' && baseAxis.type !== 'value') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var key = baseAxis.dim + '_' + baseAxis.index;\n    var dimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));\n    var store = data.getStore();\n\n    for (var i = 0, cnt = store.count(); i < cnt; ++i) {\n      var value = store.get(dimIdx, i);\n\n      if (!axisValues[key]) {\n        // No previous data for the axis\n        axisValues[key] = [value];\n      } else {\n        // No value in previous series\n        axisValues[key].push(value);\n      } // Ignore duplicated time values in the same axis\n\n    }\n  });\n  var axisMinGaps = {};\n\n  for (var key in axisValues) {\n    if (axisValues.hasOwnProperty(key)) {\n      var valuesInAxis = axisValues[key];\n\n      if (valuesInAxis) {\n        // Sort axis values into ascending order to calculate gaps\n        valuesInAxis.sort(function (a, b) {\n          return a - b;\n        });\n        var min = null;\n\n        for (var j = 1; j < valuesInAxis.length; ++j) {\n          var delta = valuesInAxis[j] - valuesInAxis[j - 1];\n\n          if (delta > 0) {\n            // Ignore 0 delta because they are of the same axis value\n            min = min === null ? delta : Math.min(min, delta);\n          }\n        } // Set to null if only have one data\n\n\n        axisMinGaps[key] = min;\n      }\n    }\n  }\n\n  return axisMinGaps;\n}\n\nexport function makeColumnLayout(barSeries) {\n  var axisMinGaps = getValueAxesMinGaps(barSeries);\n  var seriesInfoList = [];\n  each(barSeries, function (seriesModel) {\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth;\n\n    if (baseAxis.type === 'category') {\n      bandWidth = baseAxis.getBandWidth();\n    } else if (baseAxis.type === 'value' || baseAxis.type === 'time') {\n      var key = baseAxis.dim + '_' + baseAxis.index;\n      var minGap = axisMinGaps[key];\n      var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);\n      var scale = baseAxis.scale.getExtent();\n      var scaleSpan = Math.abs(scale[1] - scale[0]);\n      bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan; // When there is only one data value\n    } else {\n      var data = seriesModel.getData();\n      bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    }\n\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barMinWidth = parsePercent( // barMinWidth by default is 0.5 / 1 in cartesian. Because in value axis,\n    // the auto-calculated bar width might be less than 0.5 / 1.\n    seriesModel.get('barMinWidth') || (isInLargeMode(seriesModel) ? 0.5 : 1), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    seriesInfoList.push({\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barMinWidth: barMinWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    });\n  });\n  return doCalBarWidthAndOffset(seriesInfoList);\n}\n\nfunction doCalBarWidthAndOffset(seriesInfoList) {\n  // Columns info on each category axis. Key is cartesian name\n  var columnsMap = {};\n  each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: null,\n      gap: '20%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    }; // Caution: In a single coordinate system, these barGrid attributes\n    // will be shared by series. Consider that they have default values,\n    // only the attributes set on the last series will work.\n    // Do not change this fact unless there will be a break change.\n\n    var barWidth = seriesInfo.barWidth;\n\n    if (barWidth && !stacks[stackId].width) {\n      // See #6312, do not restrict width.\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barMinWidth = seriesInfo.barMinWidth;\n    barMinWidth && (stacks[stackId].minWidth = barMinWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGapPercent = columnsOnAxis.categoryGap;\n\n    if (categoryGapPercent == null) {\n      var columnCount = keys(stacks).length; // More columns in one group\n      // the spaces between group is smaller. Or the column will be too thin.\n\n      categoryGapPercent = Math.max(35 - columnCount * 4, 15) + '%';\n    }\n\n    var categoryGap = parsePercent(categoryGapPercent, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    each(stacks, function (column) {\n      var maxWidth = column.maxWidth;\n      var minWidth = column.minWidth;\n\n      if (!column.width) {\n        var finalWidth = autoWidth;\n\n        if (maxWidth && maxWidth < finalWidth) {\n          finalWidth = Math.min(maxWidth, remainedWidth);\n        } // `minWidth` has higher priority. `minWidth` decide that wheter the\n        // bar is able to be visible. So `minWidth` should not be restricted\n        // by `maxWidth` or `remainedWidth` (which is from `bandWidth`). In\n        // the extreme cases for `value` axis, bars are allowed to overlap\n        // with each other if `minWidth` specified.\n\n\n        if (minWidth && minWidth > finalWidth) {\n          finalWidth = minWidth;\n        }\n\n        if (finalWidth !== autoWidth) {\n          column.width = finalWidth;\n          remainedWidth -= finalWidth + barGapPercent * finalWidth;\n          autoWidthCount--;\n        }\n      } else {\n        // `barMinWidth/barMaxWidth` has higher priority than `barWidth`, as\n        // CSS does. Becuase barWidth can be a percent value, where\n        // `barMaxWidth` can be used to restrict the final width.\n        var finalWidth = column.width;\n\n        if (maxWidth) {\n          finalWidth = Math.min(finalWidth, maxWidth);\n        } // `minWidth` has higher priority, as described above\n\n\n        if (minWidth) {\n          finalWidth = Math.max(finalWidth, minWidth);\n        }\n\n        column.width = finalWidth;\n        remainedWidth -= finalWidth + barGapPercent * finalWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        bandWidth: bandWidth,\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n\nfunction retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {\n  if (barWidthAndOffset && axis) {\n    var result = barWidthAndOffset[getAxisKey(axis)];\n\n    if (result != null && seriesModel != null) {\n      return result[getSeriesStackId(seriesModel)];\n    }\n\n    return result;\n  }\n}\n\nexport { retrieveColumnLayout };\nexport function layout(seriesType, ecModel) {\n  var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);\n  var barWidthAndOffset = makeColumnLayout(seriesModels);\n  each(seriesModels, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    data.setLayout({\n      bandWidth: columnLayoutInfo.bandWidth,\n      offset: columnOffset,\n      size: columnWidth\n    });\n  });\n} // TODO: Do not support stack in large mode yet.\n\nexport function createProgressiveLayout(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      if (!isOnCartesian(seriesModel)) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      var cartesian = seriesModel.coordinateSystem;\n      var baseAxis = cartesian.getBaseAxis();\n      var valueAxis = cartesian.getOtherAxis(baseAxis);\n      var valueDimIdx = data.getDimensionIndex(data.mapDimension(valueAxis.dim));\n      var baseDimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));\n      var drawBackground = seriesModel.get('showBackground', true);\n      var valueDim = data.mapDimension(valueAxis.dim);\n      var stackResultDim = data.getCalculationInfo('stackResultDimension');\n      var stacked = isDimensionStacked(data, valueDim) && !!data.getCalculationInfo('stackedOnSeries');\n      var isValueAxisH = valueAxis.isHorizontal();\n      var valueAxisStart = getValueAxisStart(baseAxis, valueAxis);\n      var isLarge = isInLargeMode(seriesModel);\n      var barMinHeight = seriesModel.get('barMinHeight') || 0;\n      var stackedDimIdx = stackResultDim && data.getDimensionIndex(stackResultDim); // Layout info.\n\n      var columnWidth = data.getLayout('size');\n      var columnOffset = data.getLayout('offset');\n      return {\n        progress: function (params, data) {\n          var count = params.count;\n          var largePoints = isLarge && createFloat32Array(count * 3);\n          var largeBackgroundPoints = isLarge && drawBackground && createFloat32Array(count * 3);\n          var largeDataIndices = isLarge && createFloat32Array(count);\n          var coordLayout = cartesian.master.getRect();\n          var bgSize = isValueAxisH ? coordLayout.width : coordLayout.height;\n          var dataIndex;\n          var store = data.getStore();\n          var idxOffset = 0;\n\n          while ((dataIndex = params.next()) != null) {\n            var value = store.get(stacked ? stackedDimIdx : valueDimIdx, dataIndex);\n            var baseValue = store.get(baseDimIdx, dataIndex);\n            var baseCoord = valueAxisStart;\n            var startValue = void 0; // Because of the barMinHeight, we can not use the value in\n            // stackResultDimension directly.\n\n            if (stacked) {\n              startValue = +value - store.get(valueDimIdx, dataIndex);\n            }\n\n            var x = void 0;\n            var y = void 0;\n            var width = void 0;\n            var height = void 0;\n\n            if (isValueAxisH) {\n              var coord = cartesian.dataToPoint([value, baseValue]);\n\n              if (stacked) {\n                var startCoord = cartesian.dataToPoint([startValue, baseValue]);\n                baseCoord = startCoord[0];\n              }\n\n              x = baseCoord;\n              y = coord[1] + columnOffset;\n              width = coord[0] - baseCoord;\n              height = columnWidth;\n\n              if (Math.abs(width) < barMinHeight) {\n                width = (width < 0 ? -1 : 1) * barMinHeight;\n              }\n            } else {\n              var coord = cartesian.dataToPoint([baseValue, value]);\n\n              if (stacked) {\n                var startCoord = cartesian.dataToPoint([baseValue, startValue]);\n                baseCoord = startCoord[1];\n              }\n\n              x = coord[0] + columnOffset;\n              y = baseCoord;\n              width = columnWidth;\n              height = coord[1] - baseCoord;\n\n              if (Math.abs(height) < barMinHeight) {\n                // Include zero to has a positive bar\n                height = (height <= 0 ? -1 : 1) * barMinHeight;\n              }\n            }\n\n            if (!isLarge) {\n              data.setItemLayout(dataIndex, {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n              });\n            } else {\n              largePoints[idxOffset] = x;\n              largePoints[idxOffset + 1] = y;\n              largePoints[idxOffset + 2] = isValueAxisH ? width : height;\n\n              if (largeBackgroundPoints) {\n                largeBackgroundPoints[idxOffset] = isValueAxisH ? coordLayout.x : x;\n                largeBackgroundPoints[idxOffset + 1] = isValueAxisH ? y : coordLayout.y;\n                largeBackgroundPoints[idxOffset + 2] = bgSize;\n              }\n\n              largeDataIndices[dataIndex] = dataIndex;\n            }\n\n            idxOffset += 3;\n          }\n\n          if (isLarge) {\n            data.setLayout({\n              largePoints: largePoints,\n              largeDataIndices: largeDataIndices,\n              largeBackgroundPoints: largeBackgroundPoints,\n              valueAxisHorizontal: isValueAxisH\n            });\n          }\n        }\n      };\n    }\n  };\n}\n\nfunction isOnCartesian(seriesModel) {\n  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n}\n\nfunction isInLargeMode(seriesModel) {\n  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;\n} // See cases in `test/bar-start.html` and `#7412`, `#8747`.\n\n\nfunction getValueAxisStart(baseAxis, valueAxis) {\n  return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === 'log' ? 1 : 0));\n}"]},"metadata":{},"sourceType":"module"}