{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport { __extends } from \"tslib\"; // Poly path support NaN point\n\nimport Path from 'zrender/lib/graphic/Path.js';\nimport PathProxy from 'zrender/lib/core/PathProxy.js';\nimport { cubicRootAt, cubicAt } from 'zrender/lib/core/curve.js';\nvar mathMin = Math.min;\nvar mathMax = Math.max;\n\nfunction isPointNull(x, y) {\n  return isNaN(x) || isNaN(y);\n}\n/**\r\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\r\n * situations. This should be used when points are non-monotone neither in x or\r\n * y dimension.\r\n */\n\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smooth, smoothMonotone, connectNulls) {\n  var prevX;\n  var prevY;\n  var cpx0;\n  var cpy0;\n  var cpx1;\n  var cpy1;\n  var idx = start;\n  var k = 0;\n\n  for (; k < segLen; k++) {\n    var x = points[idx * 2];\n    var y = points[idx * 2 + 1];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(x, y)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](x, y);\n      cpx0 = x;\n      cpy0 = y;\n    } else {\n      var dx = x - prevX;\n      var dy = y - prevY; // Ignore tiny segment.\n\n      if (dx * dx + dy * dy < 0.5) {\n        idx += dir;\n        continue;\n      }\n\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextX = points[nextIdx * 2];\n        var nextY = points[nextIdx * 2 + 1]; // Ignore duplicate point\n\n        while (nextX === x && nextY === y && k < segLen) {\n          k++;\n          nextIdx += dir;\n          idx += dir;\n          nextX = points[nextIdx * 2];\n          nextY = points[nextIdx * 2 + 1];\n          x = points[idx * 2];\n          y = points[idx * 2 + 1];\n          dx = x - prevX;\n          dy = y - prevY;\n        }\n\n        var tmpK = k + 1;\n\n        if (connectNulls) {\n          // Find next point not null\n          while (isPointNull(nextX, nextY) && tmpK < segLen) {\n            tmpK++;\n            nextIdx += dir;\n            nextX = points[nextIdx * 2];\n            nextY = points[nextIdx * 2 + 1];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var vx = 0;\n        var vy = 0;\n        var nextCpx0 = void 0;\n        var nextCpy0 = void 0; // Is last point\n\n        if (tmpK >= segLen || isPointNull(nextX, nextY)) {\n          cpx1 = x;\n          cpy1 = y;\n        } else {\n          vx = nextX - prevX;\n          vy = nextY - prevY;\n          var dx0 = x - prevX;\n          var dx1 = nextX - x;\n          var dy0 = y - prevY;\n          var dy1 = nextY - y;\n          var lenPrevSeg = void 0;\n          var lenNextSeg = void 0;\n\n          if (smoothMonotone === 'x') {\n            lenPrevSeg = Math.abs(dx0);\n            lenNextSeg = Math.abs(dx1);\n            var dir_1 = vx > 0 ? 1 : -1;\n            cpx1 = x - dir_1 * lenPrevSeg * smooth;\n            cpy1 = y;\n            nextCpx0 = x + dir_1 * lenNextSeg * smooth;\n            nextCpy0 = y;\n          } else if (smoothMonotone === 'y') {\n            lenPrevSeg = Math.abs(dy0);\n            lenNextSeg = Math.abs(dy1);\n            var dir_2 = vy > 0 ? 1 : -1;\n            cpx1 = x;\n            cpy1 = y - dir_2 * lenPrevSeg * smooth;\n            nextCpx0 = x;\n            nextCpy0 = y + dir_2 * lenNextSeg * smooth;\n          } else {\n            lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);\n            lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1); // Use ratio of seg length\n\n            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n            cpx1 = x - vx * smooth * (1 - ratioNextSeg);\n            cpy1 = y - vy * smooth * (1 - ratioNextSeg); // cp0 of next segment\n\n            nextCpx0 = x + vx * smooth * ratioNextSeg;\n            nextCpy0 = y + vy * smooth * ratioNextSeg; // Smooth constraint between point and next point.\n            // Avoid exceeding extreme after smoothing.\n\n            nextCpx0 = mathMin(nextCpx0, mathMax(nextX, x));\n            nextCpy0 = mathMin(nextCpy0, mathMax(nextY, y));\n            nextCpx0 = mathMax(nextCpx0, mathMin(nextX, x));\n            nextCpy0 = mathMax(nextCpy0, mathMin(nextY, y)); // Reclaculate cp1 based on the adjusted cp0 of next seg.\n\n            vx = nextCpx0 - x;\n            vy = nextCpy0 - y;\n            cpx1 = x - vx * lenPrevSeg / lenNextSeg;\n            cpy1 = y - vy * lenPrevSeg / lenNextSeg; // Smooth constraint between point and prev point.\n            // Avoid exceeding extreme after smoothing.\n\n            cpx1 = mathMin(cpx1, mathMax(prevX, x));\n            cpy1 = mathMin(cpy1, mathMax(prevY, y));\n            cpx1 = mathMax(cpx1, mathMin(prevX, x));\n            cpy1 = mathMax(cpy1, mathMin(prevY, y)); // Adjust next cp0 again.\n\n            vx = x - cpx1;\n            vy = y - cpy1;\n            nextCpx0 = x + vx * lenNextSeg / lenPrevSeg;\n            nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;\n          }\n        }\n\n        ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y);\n        cpx0 = nextCpx0;\n        cpy0 = nextCpy0;\n      } else {\n        ctx.lineTo(x, y);\n      }\n    }\n\n    prevX = x;\n    prevY = y;\n    idx += dir;\n  }\n\n  return k;\n}\n\nvar ECPolylineShape =\n/** @class */\nfunction () {\n  function ECPolylineShape() {\n    this.smooth = 0;\n    this.smoothConstraint = true;\n  }\n\n  return ECPolylineShape;\n}();\n\nvar ECPolyline =\n/** @class */\nfunction (_super) {\n  __extends(ECPolyline, _super);\n\n  function ECPolyline(opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this.type = 'ec-polyline';\n    return _this;\n  }\n\n  ECPolyline.prototype.getDefaultStyle = function () {\n    return {\n      stroke: '#000',\n      fill: null\n    };\n  };\n\n  ECPolyline.prototype.getDefaultShape = function () {\n    return new ECPolylineShape();\n  };\n\n  ECPolyline.prototype.buildPath = function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length / 2; // const result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  };\n\n  ECPolyline.prototype.getPointOn = function (xOrY, dim) {\n    if (!this.path) {\n      this.createPathProxy();\n      this.buildPath(this.path, this.shape);\n    }\n\n    var path = this.path;\n    var data = path.data;\n    var CMD = PathProxy.CMD;\n    var x0;\n    var y0;\n    var isDimX = dim === 'x';\n    var roots = [];\n\n    for (var i = 0; i < data.length;) {\n      var cmd = data[i++];\n      var x = void 0;\n      var y = void 0;\n      var x2 = void 0;\n      var y2 = void 0;\n      var x3 = void 0;\n      var y3 = void 0;\n      var t = void 0;\n\n      switch (cmd) {\n        case CMD.M:\n          x0 = data[i++];\n          y0 = data[i++];\n          break;\n\n        case CMD.L:\n          x = data[i++];\n          y = data[i++];\n          t = isDimX ? (xOrY - x0) / (x - x0) : (xOrY - y0) / (y - y0);\n\n          if (t <= 1 && t >= 0) {\n            var val = isDimX ? (y - y0) * t + y0 : (x - x0) * t + x0;\n            return isDimX ? [xOrY, val] : [val, xOrY];\n          }\n\n          x0 = x;\n          y0 = y;\n          break;\n\n        case CMD.C:\n          x = data[i++];\n          y = data[i++];\n          x2 = data[i++];\n          y2 = data[i++];\n          x3 = data[i++];\n          y3 = data[i++];\n          var nRoot = isDimX ? cubicRootAt(x0, x, x2, x3, xOrY, roots) : cubicRootAt(y0, y, y2, y3, xOrY, roots);\n\n          if (nRoot > 0) {\n            for (var i_1 = 0; i_1 < nRoot; i_1++) {\n              var t_1 = roots[i_1];\n\n              if (t_1 <= 1 && t_1 >= 0) {\n                var val = isDimX ? cubicAt(y0, y, y2, y3, t_1) : cubicAt(x0, x, x2, x3, t_1);\n                return isDimX ? [xOrY, val] : [val, xOrY];\n              }\n            }\n          }\n\n          x0 = x3;\n          y0 = y3;\n          break;\n      }\n    }\n  };\n\n  return ECPolyline;\n}(Path);\n\nexport { ECPolyline };\n\nvar ECPolygonShape =\n/** @class */\nfunction (_super) {\n  __extends(ECPolygonShape, _super);\n\n  function ECPolygonShape() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return ECPolygonShape;\n}(ECPolylineShape);\n\nvar ECPolygon =\n/** @class */\nfunction (_super) {\n  __extends(ECPolygon, _super);\n\n  function ECPolygon(opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this.type = 'ec-polygon';\n    return _this;\n  }\n\n  ECPolygon.prototype.getDefaultShape = function () {\n    return new ECPolygonShape();\n  };\n\n  ECPolygon.prototype.buildPath = function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length / 2;\n    var smoothMonotone = shape.smoothMonotone;\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  };\n\n  return ECPolygon;\n}(Path);\n\nexport { ECPolygon };","map":{"version":3,"sources":["F:/Desktop/two_hours_front/node_modules/echarts/lib/chart/line/poly.js"],"names":["__extends","Path","PathProxy","cubicRootAt","cubicAt","mathMin","Math","min","mathMax","max","isPointNull","x","y","isNaN","drawSegment","ctx","points","start","segLen","allLen","dir","smooth","smoothMonotone","connectNulls","prevX","prevY","cpx0","cpy0","cpx1","cpy1","idx","k","dx","dy","nextIdx","nextX","nextY","tmpK","ratioNextSeg","vx","vy","nextCpx0","nextCpy0","dx0","dx1","dy0","dy1","lenPrevSeg","lenNextSeg","abs","dir_1","dir_2","sqrt","bezierCurveTo","lineTo","ECPolylineShape","smoothConstraint","ECPolyline","_super","opts","_this","call","type","prototype","getDefaultStyle","stroke","fill","getDefaultShape","buildPath","shape","i","len","length","getPointOn","xOrY","dim","path","createPathProxy","data","CMD","x0","y0","isDimX","roots","cmd","x2","y2","x3","y3","t","M","L","val","C","nRoot","i_1","t_1","ECPolygonShape","apply","arguments","ECPolygon","stackedOnPoints","stackedOnSmooth","closePath"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport { __extends } from \"tslib\"; // Poly path support NaN point\n\nimport Path from 'zrender/lib/graphic/Path.js';\nimport PathProxy from 'zrender/lib/core/PathProxy.js';\nimport { cubicRootAt, cubicAt } from 'zrender/lib/core/curve.js';\nvar mathMin = Math.min;\nvar mathMax = Math.max;\n\nfunction isPointNull(x, y) {\n  return isNaN(x) || isNaN(y);\n}\n/**\r\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\r\n * situations. This should be used when points are non-monotone neither in x or\r\n * y dimension.\r\n */\n\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smooth, smoothMonotone, connectNulls) {\n  var prevX;\n  var prevY;\n  var cpx0;\n  var cpy0;\n  var cpx1;\n  var cpy1;\n  var idx = start;\n  var k = 0;\n\n  for (; k < segLen; k++) {\n    var x = points[idx * 2];\n    var y = points[idx * 2 + 1];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(x, y)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](x, y);\n      cpx0 = x;\n      cpy0 = y;\n    } else {\n      var dx = x - prevX;\n      var dy = y - prevY; // Ignore tiny segment.\n\n      if (dx * dx + dy * dy < 0.5) {\n        idx += dir;\n        continue;\n      }\n\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextX = points[nextIdx * 2];\n        var nextY = points[nextIdx * 2 + 1]; // Ignore duplicate point\n\n        while (nextX === x && nextY === y && k < segLen) {\n          k++;\n          nextIdx += dir;\n          idx += dir;\n          nextX = points[nextIdx * 2];\n          nextY = points[nextIdx * 2 + 1];\n          x = points[idx * 2];\n          y = points[idx * 2 + 1];\n          dx = x - prevX;\n          dy = y - prevY;\n        }\n\n        var tmpK = k + 1;\n\n        if (connectNulls) {\n          // Find next point not null\n          while (isPointNull(nextX, nextY) && tmpK < segLen) {\n            tmpK++;\n            nextIdx += dir;\n            nextX = points[nextIdx * 2];\n            nextY = points[nextIdx * 2 + 1];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var vx = 0;\n        var vy = 0;\n        var nextCpx0 = void 0;\n        var nextCpy0 = void 0; // Is last point\n\n        if (tmpK >= segLen || isPointNull(nextX, nextY)) {\n          cpx1 = x;\n          cpy1 = y;\n        } else {\n          vx = nextX - prevX;\n          vy = nextY - prevY;\n          var dx0 = x - prevX;\n          var dx1 = nextX - x;\n          var dy0 = y - prevY;\n          var dy1 = nextY - y;\n          var lenPrevSeg = void 0;\n          var lenNextSeg = void 0;\n\n          if (smoothMonotone === 'x') {\n            lenPrevSeg = Math.abs(dx0);\n            lenNextSeg = Math.abs(dx1);\n            var dir_1 = vx > 0 ? 1 : -1;\n            cpx1 = x - dir_1 * lenPrevSeg * smooth;\n            cpy1 = y;\n            nextCpx0 = x + dir_1 * lenNextSeg * smooth;\n            nextCpy0 = y;\n          } else if (smoothMonotone === 'y') {\n            lenPrevSeg = Math.abs(dy0);\n            lenNextSeg = Math.abs(dy1);\n            var dir_2 = vy > 0 ? 1 : -1;\n            cpx1 = x;\n            cpy1 = y - dir_2 * lenPrevSeg * smooth;\n            nextCpx0 = x;\n            nextCpy0 = y + dir_2 * lenNextSeg * smooth;\n          } else {\n            lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);\n            lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1); // Use ratio of seg length\n\n            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n            cpx1 = x - vx * smooth * (1 - ratioNextSeg);\n            cpy1 = y - vy * smooth * (1 - ratioNextSeg); // cp0 of next segment\n\n            nextCpx0 = x + vx * smooth * ratioNextSeg;\n            nextCpy0 = y + vy * smooth * ratioNextSeg; // Smooth constraint between point and next point.\n            // Avoid exceeding extreme after smoothing.\n\n            nextCpx0 = mathMin(nextCpx0, mathMax(nextX, x));\n            nextCpy0 = mathMin(nextCpy0, mathMax(nextY, y));\n            nextCpx0 = mathMax(nextCpx0, mathMin(nextX, x));\n            nextCpy0 = mathMax(nextCpy0, mathMin(nextY, y)); // Reclaculate cp1 based on the adjusted cp0 of next seg.\n\n            vx = nextCpx0 - x;\n            vy = nextCpy0 - y;\n            cpx1 = x - vx * lenPrevSeg / lenNextSeg;\n            cpy1 = y - vy * lenPrevSeg / lenNextSeg; // Smooth constraint between point and prev point.\n            // Avoid exceeding extreme after smoothing.\n\n            cpx1 = mathMin(cpx1, mathMax(prevX, x));\n            cpy1 = mathMin(cpy1, mathMax(prevY, y));\n            cpx1 = mathMax(cpx1, mathMin(prevX, x));\n            cpy1 = mathMax(cpy1, mathMin(prevY, y)); // Adjust next cp0 again.\n\n            vx = x - cpx1;\n            vy = y - cpy1;\n            nextCpx0 = x + vx * lenNextSeg / lenPrevSeg;\n            nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;\n          }\n        }\n\n        ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y);\n        cpx0 = nextCpx0;\n        cpy0 = nextCpy0;\n      } else {\n        ctx.lineTo(x, y);\n      }\n    }\n\n    prevX = x;\n    prevY = y;\n    idx += dir;\n  }\n\n  return k;\n}\n\nvar ECPolylineShape =\n/** @class */\nfunction () {\n  function ECPolylineShape() {\n    this.smooth = 0;\n    this.smoothConstraint = true;\n  }\n\n  return ECPolylineShape;\n}();\n\nvar ECPolyline =\n/** @class */\nfunction (_super) {\n  __extends(ECPolyline, _super);\n\n  function ECPolyline(opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this.type = 'ec-polyline';\n    return _this;\n  }\n\n  ECPolyline.prototype.getDefaultStyle = function () {\n    return {\n      stroke: '#000',\n      fill: null\n    };\n  };\n\n  ECPolyline.prototype.getDefaultShape = function () {\n    return new ECPolylineShape();\n  };\n\n  ECPolyline.prototype.buildPath = function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length / 2; // const result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  };\n\n  ECPolyline.prototype.getPointOn = function (xOrY, dim) {\n    if (!this.path) {\n      this.createPathProxy();\n      this.buildPath(this.path, this.shape);\n    }\n\n    var path = this.path;\n    var data = path.data;\n    var CMD = PathProxy.CMD;\n    var x0;\n    var y0;\n    var isDimX = dim === 'x';\n    var roots = [];\n\n    for (var i = 0; i < data.length;) {\n      var cmd = data[i++];\n      var x = void 0;\n      var y = void 0;\n      var x2 = void 0;\n      var y2 = void 0;\n      var x3 = void 0;\n      var y3 = void 0;\n      var t = void 0;\n\n      switch (cmd) {\n        case CMD.M:\n          x0 = data[i++];\n          y0 = data[i++];\n          break;\n\n        case CMD.L:\n          x = data[i++];\n          y = data[i++];\n          t = isDimX ? (xOrY - x0) / (x - x0) : (xOrY - y0) / (y - y0);\n\n          if (t <= 1 && t >= 0) {\n            var val = isDimX ? (y - y0) * t + y0 : (x - x0) * t + x0;\n            return isDimX ? [xOrY, val] : [val, xOrY];\n          }\n\n          x0 = x;\n          y0 = y;\n          break;\n\n        case CMD.C:\n          x = data[i++];\n          y = data[i++];\n          x2 = data[i++];\n          y2 = data[i++];\n          x3 = data[i++];\n          y3 = data[i++];\n          var nRoot = isDimX ? cubicRootAt(x0, x, x2, x3, xOrY, roots) : cubicRootAt(y0, y, y2, y3, xOrY, roots);\n\n          if (nRoot > 0) {\n            for (var i_1 = 0; i_1 < nRoot; i_1++) {\n              var t_1 = roots[i_1];\n\n              if (t_1 <= 1 && t_1 >= 0) {\n                var val = isDimX ? cubicAt(y0, y, y2, y3, t_1) : cubicAt(x0, x, x2, x3, t_1);\n                return isDimX ? [xOrY, val] : [val, xOrY];\n              }\n            }\n          }\n\n          x0 = x3;\n          y0 = y3;\n          break;\n      }\n    }\n  };\n\n  return ECPolyline;\n}(Path);\n\nexport { ECPolyline };\n\nvar ECPolygonShape =\n/** @class */\nfunction (_super) {\n  __extends(ECPolygonShape, _super);\n\n  function ECPolygonShape() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return ECPolygonShape;\n}(ECPolylineShape);\n\nvar ECPolygon =\n/** @class */\nfunction (_super) {\n  __extends(ECPolygon, _super);\n\n  function ECPolygon(opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this.type = 'ec-polygon';\n    return _this;\n  }\n\n  ECPolygon.prototype.getDefaultShape = function () {\n    return new ECPolygonShape();\n  };\n\n  ECPolygon.prototype.buildPath = function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length / 2;\n    var smoothMonotone = shape.smoothMonotone;\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  };\n\n  return ECPolygon;\n}(Path);\n\nexport { ECPolygon };"]},"metadata":{},"sourceType":"module"}