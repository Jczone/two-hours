{"ast":null,"code":"import \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.error.cause.js\";\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * Grid is a region which contains at most 4 cartesian systems\r\n *\r\n * TODO Default cartesian\r\n */\nimport { isObject, each, indexOf, retrieve3, keys } from 'zrender/lib/core/util.js';\nimport { getLayoutRect } from '../../util/layout.js';\nimport { createScaleByModel, ifAxisCrossZero, niceScaleExtent, estimateLabelUnionRect, getDataDimensionsOnAxis } from '../../coord/axisHelper.js';\nimport Cartesian2D, { cartesian2DDimensions } from './Cartesian2D.js';\nimport Axis2D from './Axis2D.js';\nimport { SINGLE_REFERRING } from '../../util/model.js';\nimport { isCartesian2DSeries, findAxisModels } from './cartesianAxisHelper.js';\nimport { isIntervalOrLogScale } from '../../scale/helper.js';\nimport { alignScaleTicks } from '../axisAlignTicks.js';\n\nvar Grid =\n/** @class */\nfunction () {\n  function Grid(gridModel, ecModel, api) {\n    // FIXME:TS where used (different from registered type 'cartesian2d')?\n    this.type = 'grid';\n    this._coordsMap = {};\n    this._coordsList = [];\n    this._axesMap = {};\n    this._axesList = [];\n    this.axisPointerEnabled = true;\n    this.dimensions = cartesian2DDimensions;\n\n    this._initCartesian(gridModel, ecModel, api);\n\n    this.model = gridModel;\n  }\n\n  Grid.prototype.getRect = function () {\n    return this._rect;\n  };\n\n  Grid.prototype.update = function (ecModel, api) {\n    var axesMap = this._axesMap;\n\n    this._updateScale(ecModel, this.model);\n\n    function updateAxisTicks(axes) {\n      var alignTo; // Axis is added in order of axisIndex.\n\n      var axesIndices = keys(axes);\n      var len = axesIndices.length;\n\n      if (!len) {\n        return;\n      }\n\n      var axisNeedsAlign = []; // Process once and calculate the ticks for those don't use alignTicks.\n\n      for (var i = len - 1; i >= 0; i--) {\n        var idx = +axesIndices[i]; // Convert to number.\n\n        var axis = axes[idx];\n        var model = axis.model;\n        var scale = axis.scale;\n\n        if ( // Only value and log axis without interval support alignTicks.\n        isIntervalOrLogScale(scale) && model.get('alignTicks') && model.get('interval') == null) {\n          axisNeedsAlign.push(axis);\n        } else {\n          niceScaleExtent(scale, model);\n\n          if (isIntervalOrLogScale(scale)) {\n            // Can only align to interval or log axis.\n            alignTo = axis;\n          }\n        }\n      }\n\n      ; // All axes has set alignTicks. Pick the first one.\n      // PENDING. Should we find the axis that both set interval, min, max and align to this one?\n\n      if (axisNeedsAlign.length) {\n        if (!alignTo) {\n          alignTo = axisNeedsAlign.pop();\n          niceScaleExtent(alignTo.scale, alignTo.model);\n        }\n\n        each(axisNeedsAlign, function (axis) {\n          alignScaleTicks(axis.scale, axis.model, alignTo.scale);\n        });\n      }\n    }\n\n    updateAxisTicks(axesMap.x);\n    updateAxisTicks(axesMap.y); // Key: axisDim_axisIndex, value: boolean, whether onZero target.\n\n    var onZeroRecords = {};\n    each(axesMap.x, function (xAxis) {\n      fixAxisOnZero(axesMap, 'y', xAxis, onZeroRecords);\n    });\n    each(axesMap.y, function (yAxis) {\n      fixAxisOnZero(axesMap, 'x', yAxis, onZeroRecords);\n    }); // Resize again if containLabel is enabled\n    // FIXME It may cause getting wrong grid size in data processing stage\n\n    this.resize(this.model, api);\n  };\n  /**\r\n   * Resize the grid\r\n   */\n\n\n  Grid.prototype.resize = function (gridModel, api, ignoreContainLabel) {\n    var boxLayoutParams = gridModel.getBoxLayoutParams();\n    var isContainLabel = !ignoreContainLabel && gridModel.get('containLabel');\n    var gridRect = getLayoutRect(boxLayoutParams, {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n    this._rect = gridRect;\n    var axesList = this._axesList;\n    adjustAxes(); // Minus label size\n\n    if (isContainLabel) {\n      each(axesList, function (axis) {\n        if (!axis.model.get(['axisLabel', 'inside'])) {\n          var labelUnionRect = estimateLabelUnionRect(axis);\n\n          if (labelUnionRect) {\n            var dim = axis.isHorizontal() ? 'height' : 'width';\n            var margin = axis.model.get(['axisLabel', 'margin']);\n            gridRect[dim] -= labelUnionRect[dim] + margin;\n\n            if (axis.position === 'top') {\n              gridRect.y += labelUnionRect.height + margin;\n            } else if (axis.position === 'left') {\n              gridRect.x += labelUnionRect.width + margin;\n            }\n          }\n        }\n      });\n      adjustAxes();\n    }\n\n    each(this._coordsList, function (coord) {\n      // Calculate affine matrix to accelerate the data to point transform.\n      // If all the axes scales are time or value.\n      coord.calcAffineTransform();\n    });\n\n    function adjustAxes() {\n      each(axesList, function (axis) {\n        var isHorizontal = axis.isHorizontal();\n        var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n        var idx = axis.inverse ? 1 : 0;\n        axis.setExtent(extent[idx], extent[1 - idx]);\n        updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);\n      });\n    }\n  };\n\n  Grid.prototype.getAxis = function (dim, axisIndex) {\n    var axesMapOnDim = this._axesMap[dim];\n\n    if (axesMapOnDim != null) {\n      return axesMapOnDim[axisIndex || 0];\n    }\n  };\n\n  Grid.prototype.getAxes = function () {\n    return this._axesList.slice();\n  };\n\n  Grid.prototype.getCartesian = function (xAxisIndex, yAxisIndex) {\n    if (xAxisIndex != null && yAxisIndex != null) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      return this._coordsMap[key];\n    }\n\n    if (isObject(xAxisIndex)) {\n      yAxisIndex = xAxisIndex.yAxisIndex;\n      xAxisIndex = xAxisIndex.xAxisIndex;\n    }\n\n    for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n      if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n        return coordList[i];\n      }\n    }\n  };\n\n  Grid.prototype.getCartesians = function () {\n    return this._coordsList.slice();\n  };\n  /**\r\n   * @implements\r\n   */\n\n\n  Grid.prototype.convertToPixel = function (ecModel, finder, value) {\n    var target = this._findConvertTarget(finder);\n\n    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n  };\n  /**\r\n   * @implements\r\n   */\n\n\n  Grid.prototype.convertFromPixel = function (ecModel, finder, value) {\n    var target = this._findConvertTarget(finder);\n\n    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n  };\n\n  Grid.prototype._findConvertTarget = function (finder) {\n    var seriesModel = finder.seriesModel;\n    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis', SINGLE_REFERRING).models[0];\n    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis', SINGLE_REFERRING).models[0];\n    var gridModel = finder.gridModel;\n    var coordsList = this._coordsList;\n    var cartesian;\n    var axis;\n\n    if (seriesModel) {\n      cartesian = seriesModel.coordinateSystem;\n      indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n    } else if (xAxisModel && yAxisModel) {\n      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n    } else if (xAxisModel) {\n      axis = this.getAxis('x', xAxisModel.componentIndex);\n    } else if (yAxisModel) {\n      axis = this.getAxis('y', yAxisModel.componentIndex);\n    } // Lowest priority.\n    else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n\n    return {\n      cartesian: cartesian,\n      axis: axis\n    };\n  };\n  /**\r\n   * @implements\r\n   */\n\n\n  Grid.prototype.containPoint = function (point) {\n    var coord = this._coordsList[0];\n\n    if (coord) {\n      return coord.containPoint(point);\n    }\n  };\n  /**\r\n   * Initialize cartesian coordinate systems\r\n   */\n\n\n  Grid.prototype._initCartesian = function (gridModel, ecModel, api) {\n    var _this = this;\n\n    var grid = this;\n    var axisPositionUsed = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false\n    };\n    var axesMap = {\n      x: {},\n      y: {}\n    };\n    var axesCount = {\n      x: 0,\n      y: 0\n    }; /// Create axis\n\n    ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n    ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n    if (!axesCount.x || !axesCount.y) {\n      // Roll back when there no either x or y axis\n      this._axesMap = {};\n      this._axesList = [];\n      return;\n    }\n\n    this._axesMap = axesMap; /// Create cartesian2d\n\n    each(axesMap.x, function (xAxis, xAxisIndex) {\n      each(axesMap.y, function (yAxis, yAxisIndex) {\n        var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n        var cartesian = new Cartesian2D(key);\n        cartesian.master = _this;\n        cartesian.model = gridModel;\n        _this._coordsMap[key] = cartesian;\n\n        _this._coordsList.push(cartesian);\n\n        cartesian.addAxis(xAxis);\n        cartesian.addAxis(yAxis);\n      });\n    });\n\n    function createAxisCreator(dimName) {\n      return function (axisModel, idx) {\n        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {\n          return;\n        }\n\n        var axisPosition = axisModel.get('position');\n\n        if (dimName === 'x') {\n          // Fix position\n          if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n            // Default bottom of X\n            axisPosition = axisPositionUsed.bottom ? 'top' : 'bottom';\n          }\n        } else {\n          // Fix position\n          if (axisPosition !== 'left' && axisPosition !== 'right') {\n            // Default left of Y\n            axisPosition = axisPositionUsed.left ? 'right' : 'left';\n          }\n        }\n\n        axisPositionUsed[axisPosition] = true;\n        var axis = new Axis2D(dimName, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n        var isCategory = axis.type === 'category';\n        axis.onBand = isCategory && axisModel.get('boundaryGap');\n        axis.inverse = axisModel.get('inverse'); // Inject axis into axisModel\n\n        axisModel.axis = axis; // Inject axisModel into axis\n\n        axis.model = axisModel; // Inject grid info axis\n\n        axis.grid = grid; // Index of axis, can be used as key\n\n        axis.index = idx;\n\n        grid._axesList.push(axis);\n\n        axesMap[dimName][idx] = axis;\n        axesCount[dimName]++;\n      };\n    }\n  };\n  /**\r\n   * Update cartesian properties from series.\r\n   */\n\n\n  Grid.prototype._updateScale = function (ecModel, gridModel) {\n    // Reset scale\n    each(this._axesList, function (axis) {\n      axis.scale.setExtent(Infinity, -Infinity);\n\n      if (axis.type === 'category') {\n        var categorySortInfo = axis.model.get('categorySortInfo');\n        axis.scale.setSortInfo(categorySortInfo);\n      }\n    });\n    ecModel.eachSeries(function (seriesModel) {\n      if (isCartesian2DSeries(seriesModel)) {\n        var axesModelMap = findAxisModels(seriesModel);\n        var xAxisModel = axesModelMap.xAxisModel;\n        var yAxisModel = axesModelMap.yAxisModel;\n\n        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {\n          return;\n        }\n\n        var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        var data = seriesModel.getData();\n        var xAxis = cartesian.getAxis('x');\n        var yAxis = cartesian.getAxis('y');\n        unionExtent(data, xAxis);\n        unionExtent(data, yAxis);\n      }\n    }, this);\n\n    function unionExtent(data, axis) {\n      each(getDataDimensionsOnAxis(data, axis.dim), function (dim) {\n        axis.scale.unionExtentFromData(data, dim);\n      });\n    }\n  };\n  /**\r\n   * @param dim 'x' or 'y' or 'auto' or null/undefined\r\n   */\n\n\n  Grid.prototype.getTooltipAxes = function (dim) {\n    var baseAxes = [];\n    var otherAxes = [];\n    each(this.getCartesians(), function (cartesian) {\n      var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n      var otherAxis = cartesian.getOtherAxis(baseAxis);\n      indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n      indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n    });\n    return {\n      baseAxes: baseAxes,\n      otherAxes: otherAxes\n    };\n  };\n\n  Grid.create = function (ecModel, api) {\n    var grids = [];\n    ecModel.eachComponent('grid', function (gridModel, idx) {\n      var grid = new Grid(gridModel, ecModel, api);\n      grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n      // should be performed in create stage.\n\n      grid.resize(gridModel, api, true);\n      gridModel.coordinateSystem = grid;\n      grids.push(grid);\n    }); // Inject the coordinateSystems into seriesModel\n\n    ecModel.eachSeries(function (seriesModel) {\n      if (!isCartesian2DSeries(seriesModel)) {\n        return;\n      }\n\n      var axesModelMap = findAxisModels(seriesModel);\n      var xAxisModel = axesModelMap.xAxisModel;\n      var yAxisModel = axesModelMap.yAxisModel;\n      var gridModel = xAxisModel.getCoordSysModel();\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (!gridModel) {\n          throw new Error('Grid \"' + retrieve3(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '\" not found');\n        }\n\n        if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {\n          throw new Error('xAxis and yAxis must use the same grid');\n        }\n      }\n\n      var grid = gridModel.coordinateSystem;\n      seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n    });\n    return grids;\n  }; // For deciding which dimensions to use when creating list data\n\n\n  Grid.dimensions = cartesian2DDimensions;\n  return Grid;\n}();\n/**\r\n * Check if the axis is used in the specified grid.\r\n */\n\n\nfunction isAxisUsedInTheGrid(axisModel, gridModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis, // Key: see `getOnZeroRecordKey`\nonZeroRecords) {\n  axis.getAxesOnZeroOf = function () {\n    // TODO: onZero of multiple axes.\n    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];\n  }; // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n\n\n  var otherAxes = axesMap[otherAxisDim];\n  var otherAxisOnZeroOf;\n  var axisModel = axis.model;\n  var onZero = axisModel.get(['axisLine', 'onZero']);\n  var onZeroAxisIndex = axisModel.get(['axisLine', 'onZeroAxisIndex']);\n\n  if (!onZero) {\n    return;\n  } // If target axis is specified.\n\n\n  if (onZeroAxisIndex != null) {\n    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {\n      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];\n    }\n  } else {\n    // Find the first available other axis.\n    for (var idx in otherAxes) {\n      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) // Consider that two Y axes on one value axis,\n      // if both onZero, the two Y axes overlap.\n      && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {\n        otherAxisOnZeroOf = otherAxes[idx];\n        break;\n      }\n    }\n  }\n\n  if (otherAxisOnZeroOf) {\n    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;\n  }\n\n  function getOnZeroRecordKey(axis) {\n    return axis.dim + '_' + axis.index;\n  }\n}\n\nfunction canOnZeroToAxis(axis) {\n  return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero(axis);\n}\n\nfunction updateAxisTransform(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nexport default Grid;","map":{"version":3,"sources":["F:/Desktop/two_hours_front/node_modules/echarts/lib/coord/cartesian/Grid.js"],"names":["isObject","each","indexOf","retrieve3","keys","getLayoutRect","createScaleByModel","ifAxisCrossZero","niceScaleExtent","estimateLabelUnionRect","getDataDimensionsOnAxis","Cartesian2D","cartesian2DDimensions","Axis2D","SINGLE_REFERRING","isCartesian2DSeries","findAxisModels","isIntervalOrLogScale","alignScaleTicks","Grid","gridModel","ecModel","api","type","_coordsMap","_coordsList","_axesMap","_axesList","axisPointerEnabled","dimensions","_initCartesian","model","prototype","getRect","_rect","update","axesMap","_updateScale","updateAxisTicks","axes","alignTo","axesIndices","len","length","axisNeedsAlign","i","idx","axis","scale","get","push","pop","x","y","onZeroRecords","xAxis","fixAxisOnZero","yAxis","resize","ignoreContainLabel","boxLayoutParams","getBoxLayoutParams","isContainLabel","gridRect","width","getWidth","height","getHeight","axesList","adjustAxes","labelUnionRect","dim","isHorizontal","margin","position","coord","calcAffineTransform","extent","inverse","setExtent","updateAxisTransform","getAxis","axisIndex","axesMapOnDim","getAxes","slice","getCartesian","xAxisIndex","yAxisIndex","key","coordList","index","getCartesians","convertToPixel","finder","value","target","_findConvertTarget","cartesian","dataToPoint","toGlobalCoord","dataToCoord","convertFromPixel","pointToData","coordToData","toLocalCoord","seriesModel","xAxisModel","getReferringComponents","models","yAxisModel","coordsList","coordinateSystem","componentIndex","grid","containPoint","point","_this","axisPositionUsed","left","right","top","bottom","axesCount","eachComponent","createAxisCreator","master","addAxis","dimName","axisModel","isAxisUsedInTheGrid","axisPosition","isCategory","onBand","Infinity","categorySortInfo","setSortInfo","eachSeries","axesModelMap","data","getData","unionExtent","unionExtentFromData","getTooltipAxes","baseAxes","otherAxes","baseAxis","getBaseAxis","otherAxis","getOtherAxis","create","grids","name","getCoordSysModel","process","env","NODE_ENV","Error","otherAxisDim","getAxesOnZeroOf","otherAxisOnZeroOf","onZero","onZeroAxisIndex","canOnZeroToAxis","hasOwnProperty","getOnZeroRecordKey","coordBase","axisExtent","getExtent","axisExtentSum"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * Grid is a region which contains at most 4 cartesian systems\r\n *\r\n * TODO Default cartesian\r\n */\nimport { isObject, each, indexOf, retrieve3, keys } from 'zrender/lib/core/util.js';\nimport { getLayoutRect } from '../../util/layout.js';\nimport { createScaleByModel, ifAxisCrossZero, niceScaleExtent, estimateLabelUnionRect, getDataDimensionsOnAxis } from '../../coord/axisHelper.js';\nimport Cartesian2D, { cartesian2DDimensions } from './Cartesian2D.js';\nimport Axis2D from './Axis2D.js';\nimport { SINGLE_REFERRING } from '../../util/model.js';\nimport { isCartesian2DSeries, findAxisModels } from './cartesianAxisHelper.js';\nimport { isIntervalOrLogScale } from '../../scale/helper.js';\nimport { alignScaleTicks } from '../axisAlignTicks.js';\n\nvar Grid =\n/** @class */\nfunction () {\n  function Grid(gridModel, ecModel, api) {\n    // FIXME:TS where used (different from registered type 'cartesian2d')?\n    this.type = 'grid';\n    this._coordsMap = {};\n    this._coordsList = [];\n    this._axesMap = {};\n    this._axesList = [];\n    this.axisPointerEnabled = true;\n    this.dimensions = cartesian2DDimensions;\n\n    this._initCartesian(gridModel, ecModel, api);\n\n    this.model = gridModel;\n  }\n\n  Grid.prototype.getRect = function () {\n    return this._rect;\n  };\n\n  Grid.prototype.update = function (ecModel, api) {\n    var axesMap = this._axesMap;\n\n    this._updateScale(ecModel, this.model);\n\n    function updateAxisTicks(axes) {\n      var alignTo; // Axis is added in order of axisIndex.\n\n      var axesIndices = keys(axes);\n      var len = axesIndices.length;\n\n      if (!len) {\n        return;\n      }\n\n      var axisNeedsAlign = []; // Process once and calculate the ticks for those don't use alignTicks.\n\n      for (var i = len - 1; i >= 0; i--) {\n        var idx = +axesIndices[i]; // Convert to number.\n\n        var axis = axes[idx];\n        var model = axis.model;\n        var scale = axis.scale;\n\n        if ( // Only value and log axis without interval support alignTicks.\n        isIntervalOrLogScale(scale) && model.get('alignTicks') && model.get('interval') == null) {\n          axisNeedsAlign.push(axis);\n        } else {\n          niceScaleExtent(scale, model);\n\n          if (isIntervalOrLogScale(scale)) {\n            // Can only align to interval or log axis.\n            alignTo = axis;\n          }\n        }\n      }\n\n      ; // All axes has set alignTicks. Pick the first one.\n      // PENDING. Should we find the axis that both set interval, min, max and align to this one?\n\n      if (axisNeedsAlign.length) {\n        if (!alignTo) {\n          alignTo = axisNeedsAlign.pop();\n          niceScaleExtent(alignTo.scale, alignTo.model);\n        }\n\n        each(axisNeedsAlign, function (axis) {\n          alignScaleTicks(axis.scale, axis.model, alignTo.scale);\n        });\n      }\n    }\n\n    updateAxisTicks(axesMap.x);\n    updateAxisTicks(axesMap.y); // Key: axisDim_axisIndex, value: boolean, whether onZero target.\n\n    var onZeroRecords = {};\n    each(axesMap.x, function (xAxis) {\n      fixAxisOnZero(axesMap, 'y', xAxis, onZeroRecords);\n    });\n    each(axesMap.y, function (yAxis) {\n      fixAxisOnZero(axesMap, 'x', yAxis, onZeroRecords);\n    }); // Resize again if containLabel is enabled\n    // FIXME It may cause getting wrong grid size in data processing stage\n\n    this.resize(this.model, api);\n  };\n  /**\r\n   * Resize the grid\r\n   */\n\n\n  Grid.prototype.resize = function (gridModel, api, ignoreContainLabel) {\n    var boxLayoutParams = gridModel.getBoxLayoutParams();\n    var isContainLabel = !ignoreContainLabel && gridModel.get('containLabel');\n    var gridRect = getLayoutRect(boxLayoutParams, {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n    this._rect = gridRect;\n    var axesList = this._axesList;\n    adjustAxes(); // Minus label size\n\n    if (isContainLabel) {\n      each(axesList, function (axis) {\n        if (!axis.model.get(['axisLabel', 'inside'])) {\n          var labelUnionRect = estimateLabelUnionRect(axis);\n\n          if (labelUnionRect) {\n            var dim = axis.isHorizontal() ? 'height' : 'width';\n            var margin = axis.model.get(['axisLabel', 'margin']);\n            gridRect[dim] -= labelUnionRect[dim] + margin;\n\n            if (axis.position === 'top') {\n              gridRect.y += labelUnionRect.height + margin;\n            } else if (axis.position === 'left') {\n              gridRect.x += labelUnionRect.width + margin;\n            }\n          }\n        }\n      });\n      adjustAxes();\n    }\n\n    each(this._coordsList, function (coord) {\n      // Calculate affine matrix to accelerate the data to point transform.\n      // If all the axes scales are time or value.\n      coord.calcAffineTransform();\n    });\n\n    function adjustAxes() {\n      each(axesList, function (axis) {\n        var isHorizontal = axis.isHorizontal();\n        var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n        var idx = axis.inverse ? 1 : 0;\n        axis.setExtent(extent[idx], extent[1 - idx]);\n        updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);\n      });\n    }\n  };\n\n  Grid.prototype.getAxis = function (dim, axisIndex) {\n    var axesMapOnDim = this._axesMap[dim];\n\n    if (axesMapOnDim != null) {\n      return axesMapOnDim[axisIndex || 0];\n    }\n  };\n\n  Grid.prototype.getAxes = function () {\n    return this._axesList.slice();\n  };\n\n  Grid.prototype.getCartesian = function (xAxisIndex, yAxisIndex) {\n    if (xAxisIndex != null && yAxisIndex != null) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      return this._coordsMap[key];\n    }\n\n    if (isObject(xAxisIndex)) {\n      yAxisIndex = xAxisIndex.yAxisIndex;\n      xAxisIndex = xAxisIndex.xAxisIndex;\n    }\n\n    for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n      if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n        return coordList[i];\n      }\n    }\n  };\n\n  Grid.prototype.getCartesians = function () {\n    return this._coordsList.slice();\n  };\n  /**\r\n   * @implements\r\n   */\n\n\n  Grid.prototype.convertToPixel = function (ecModel, finder, value) {\n    var target = this._findConvertTarget(finder);\n\n    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n  };\n  /**\r\n   * @implements\r\n   */\n\n\n  Grid.prototype.convertFromPixel = function (ecModel, finder, value) {\n    var target = this._findConvertTarget(finder);\n\n    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n  };\n\n  Grid.prototype._findConvertTarget = function (finder) {\n    var seriesModel = finder.seriesModel;\n    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis', SINGLE_REFERRING).models[0];\n    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis', SINGLE_REFERRING).models[0];\n    var gridModel = finder.gridModel;\n    var coordsList = this._coordsList;\n    var cartesian;\n    var axis;\n\n    if (seriesModel) {\n      cartesian = seriesModel.coordinateSystem;\n      indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n    } else if (xAxisModel && yAxisModel) {\n      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n    } else if (xAxisModel) {\n      axis = this.getAxis('x', xAxisModel.componentIndex);\n    } else if (yAxisModel) {\n      axis = this.getAxis('y', yAxisModel.componentIndex);\n    } // Lowest priority.\n    else if (gridModel) {\n        var grid = gridModel.coordinateSystem;\n\n        if (grid === this) {\n          cartesian = this._coordsList[0];\n        }\n      }\n\n    return {\n      cartesian: cartesian,\n      axis: axis\n    };\n  };\n  /**\r\n   * @implements\r\n   */\n\n\n  Grid.prototype.containPoint = function (point) {\n    var coord = this._coordsList[0];\n\n    if (coord) {\n      return coord.containPoint(point);\n    }\n  };\n  /**\r\n   * Initialize cartesian coordinate systems\r\n   */\n\n\n  Grid.prototype._initCartesian = function (gridModel, ecModel, api) {\n    var _this = this;\n\n    var grid = this;\n    var axisPositionUsed = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false\n    };\n    var axesMap = {\n      x: {},\n      y: {}\n    };\n    var axesCount = {\n      x: 0,\n      y: 0\n    }; /// Create axis\n\n    ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n    ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n    if (!axesCount.x || !axesCount.y) {\n      // Roll back when there no either x or y axis\n      this._axesMap = {};\n      this._axesList = [];\n      return;\n    }\n\n    this._axesMap = axesMap; /// Create cartesian2d\n\n    each(axesMap.x, function (xAxis, xAxisIndex) {\n      each(axesMap.y, function (yAxis, yAxisIndex) {\n        var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n        var cartesian = new Cartesian2D(key);\n        cartesian.master = _this;\n        cartesian.model = gridModel;\n        _this._coordsMap[key] = cartesian;\n\n        _this._coordsList.push(cartesian);\n\n        cartesian.addAxis(xAxis);\n        cartesian.addAxis(yAxis);\n      });\n    });\n\n    function createAxisCreator(dimName) {\n      return function (axisModel, idx) {\n        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {\n          return;\n        }\n\n        var axisPosition = axisModel.get('position');\n\n        if (dimName === 'x') {\n          // Fix position\n          if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n            // Default bottom of X\n            axisPosition = axisPositionUsed.bottom ? 'top' : 'bottom';\n          }\n        } else {\n          // Fix position\n          if (axisPosition !== 'left' && axisPosition !== 'right') {\n            // Default left of Y\n            axisPosition = axisPositionUsed.left ? 'right' : 'left';\n          }\n        }\n\n        axisPositionUsed[axisPosition] = true;\n        var axis = new Axis2D(dimName, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n        var isCategory = axis.type === 'category';\n        axis.onBand = isCategory && axisModel.get('boundaryGap');\n        axis.inverse = axisModel.get('inverse'); // Inject axis into axisModel\n\n        axisModel.axis = axis; // Inject axisModel into axis\n\n        axis.model = axisModel; // Inject grid info axis\n\n        axis.grid = grid; // Index of axis, can be used as key\n\n        axis.index = idx;\n\n        grid._axesList.push(axis);\n\n        axesMap[dimName][idx] = axis;\n        axesCount[dimName]++;\n      };\n    }\n  };\n  /**\r\n   * Update cartesian properties from series.\r\n   */\n\n\n  Grid.prototype._updateScale = function (ecModel, gridModel) {\n    // Reset scale\n    each(this._axesList, function (axis) {\n      axis.scale.setExtent(Infinity, -Infinity);\n\n      if (axis.type === 'category') {\n        var categorySortInfo = axis.model.get('categorySortInfo');\n        axis.scale.setSortInfo(categorySortInfo);\n      }\n    });\n    ecModel.eachSeries(function (seriesModel) {\n      if (isCartesian2DSeries(seriesModel)) {\n        var axesModelMap = findAxisModels(seriesModel);\n        var xAxisModel = axesModelMap.xAxisModel;\n        var yAxisModel = axesModelMap.yAxisModel;\n\n        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {\n          return;\n        }\n\n        var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        var data = seriesModel.getData();\n        var xAxis = cartesian.getAxis('x');\n        var yAxis = cartesian.getAxis('y');\n        unionExtent(data, xAxis);\n        unionExtent(data, yAxis);\n      }\n    }, this);\n\n    function unionExtent(data, axis) {\n      each(getDataDimensionsOnAxis(data, axis.dim), function (dim) {\n        axis.scale.unionExtentFromData(data, dim);\n      });\n    }\n  };\n  /**\r\n   * @param dim 'x' or 'y' or 'auto' or null/undefined\r\n   */\n\n\n  Grid.prototype.getTooltipAxes = function (dim) {\n    var baseAxes = [];\n    var otherAxes = [];\n    each(this.getCartesians(), function (cartesian) {\n      var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n      var otherAxis = cartesian.getOtherAxis(baseAxis);\n      indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n      indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n    });\n    return {\n      baseAxes: baseAxes,\n      otherAxes: otherAxes\n    };\n  };\n\n  Grid.create = function (ecModel, api) {\n    var grids = [];\n    ecModel.eachComponent('grid', function (gridModel, idx) {\n      var grid = new Grid(gridModel, ecModel, api);\n      grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n      // should be performed in create stage.\n\n      grid.resize(gridModel, api, true);\n      gridModel.coordinateSystem = grid;\n      grids.push(grid);\n    }); // Inject the coordinateSystems into seriesModel\n\n    ecModel.eachSeries(function (seriesModel) {\n      if (!isCartesian2DSeries(seriesModel)) {\n        return;\n      }\n\n      var axesModelMap = findAxisModels(seriesModel);\n      var xAxisModel = axesModelMap.xAxisModel;\n      var yAxisModel = axesModelMap.yAxisModel;\n      var gridModel = xAxisModel.getCoordSysModel();\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (!gridModel) {\n          throw new Error('Grid \"' + retrieve3(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '\" not found');\n        }\n\n        if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {\n          throw new Error('xAxis and yAxis must use the same grid');\n        }\n      }\n\n      var grid = gridModel.coordinateSystem;\n      seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n    });\n    return grids;\n  }; // For deciding which dimensions to use when creating list data\n\n\n  Grid.dimensions = cartesian2DDimensions;\n  return Grid;\n}();\n/**\r\n * Check if the axis is used in the specified grid.\r\n */\n\n\nfunction isAxisUsedInTheGrid(axisModel, gridModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis, // Key: see `getOnZeroRecordKey`\nonZeroRecords) {\n  axis.getAxesOnZeroOf = function () {\n    // TODO: onZero of multiple axes.\n    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];\n  }; // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n\n\n  var otherAxes = axesMap[otherAxisDim];\n  var otherAxisOnZeroOf;\n  var axisModel = axis.model;\n  var onZero = axisModel.get(['axisLine', 'onZero']);\n  var onZeroAxisIndex = axisModel.get(['axisLine', 'onZeroAxisIndex']);\n\n  if (!onZero) {\n    return;\n  } // If target axis is specified.\n\n\n  if (onZeroAxisIndex != null) {\n    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {\n      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];\n    }\n  } else {\n    // Find the first available other axis.\n    for (var idx in otherAxes) {\n      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) // Consider that two Y axes on one value axis,\n      // if both onZero, the two Y axes overlap.\n      && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {\n        otherAxisOnZeroOf = otherAxes[idx];\n        break;\n      }\n    }\n  }\n\n  if (otherAxisOnZeroOf) {\n    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;\n  }\n\n  function getOnZeroRecordKey(axis) {\n    return axis.dim + '_' + axis.index;\n  }\n}\n\nfunction canOnZeroToAxis(axis) {\n  return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero(axis);\n}\n\nfunction updateAxisTransform(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nexport default Grid;"]},"metadata":{},"sourceType":"module"}