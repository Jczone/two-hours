{"ast":null,"code":"import \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.sort.js\";\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport * as zrColor from 'zrender/lib/tool/color.js';\nimport { linearMap } from '../util/number.js';\nimport { warn } from '../util/log.js';\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\nvar CATEGORY_DEFAULT_VISUAL_INDEX = -1;\n\nvar VisualMapping =\n/** @class */\nfunction () {\n  function VisualMapping(option) {\n    var mappingMethod = option.mappingMethod;\n    var visualType = option.type;\n    var thisOption = this.option = zrUtil.clone(option);\n    this.type = visualType;\n    this.mappingMethod = mappingMethod;\n    this._normalizeData = normalizers[mappingMethod];\n    var visualHandler = VisualMapping.visualHandlers[visualType];\n    this.applyVisual = visualHandler.applyVisual;\n    this.getColorMapper = visualHandler.getColorMapper;\n    this._normalizedToVisual = visualHandler._normalizedToVisual[mappingMethod];\n\n    if (mappingMethod === 'piecewise') {\n      normalizeVisualRange(thisOption);\n      preprocessForPiecewise(thisOption);\n    } else if (mappingMethod === 'category') {\n      thisOption.categories ? preprocessForSpecifiedCategory(thisOption) // categories is ordinal when thisOption.categories not specified,\n      // which need no more preprocess except normalize visual.\n      : normalizeVisualRange(thisOption, true);\n    } else {\n      // mappingMethod === 'linear' or 'fixed'\n      zrUtil.assert(mappingMethod !== 'linear' || thisOption.dataExtent);\n      normalizeVisualRange(thisOption);\n    }\n  }\n\n  VisualMapping.prototype.mapValueToVisual = function (value) {\n    var normalized = this._normalizeData(value);\n\n    return this._normalizedToVisual(normalized, value);\n  };\n\n  VisualMapping.prototype.getNormalizer = function () {\n    return zrUtil.bind(this._normalizeData, this);\n  };\n  /**\r\n   * List available visual types.\r\n   *\r\n   * @public\r\n   * @return {Array.<string>}\r\n   */\n\n\n  VisualMapping.listVisualTypes = function () {\n    return zrUtil.keys(VisualMapping.visualHandlers);\n  }; // /**\n  //  * @public\n  //  */\n  // static addVisualHandler(name, handler) {\n  //     visualHandlers[name] = handler;\n  // }\n\n  /**\r\n   * @public\r\n   */\n\n\n  VisualMapping.isValidType = function (visualType) {\n    return VisualMapping.visualHandlers.hasOwnProperty(visualType);\n  };\n  /**\r\n   * Convinent method.\r\n   * Visual can be Object or Array or primary type.\r\n   */\n\n\n  VisualMapping.eachVisual = function (visual, callback, context) {\n    if (zrUtil.isObject(visual)) {\n      zrUtil.each(visual, callback, context);\n    } else {\n      callback.call(context, visual);\n    }\n  };\n\n  VisualMapping.mapVisual = function (visual, callback, context) {\n    var isPrimary;\n    var newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = true, null);\n    VisualMapping.eachVisual(visual, function (v, key) {\n      var newVal = callback.call(context, v, key);\n      isPrimary ? newVisual = newVal : newVisual[key] = newVal;\n    });\n    return newVisual;\n  };\n  /**\r\n   * Retrieve visual properties from given object.\r\n   */\n\n\n  VisualMapping.retrieveVisuals = function (obj) {\n    var ret = {};\n    var hasVisual;\n    obj && each(VisualMapping.visualHandlers, function (h, visualType) {\n      if (obj.hasOwnProperty(visualType)) {\n        ret[visualType] = obj[visualType];\n        hasVisual = true;\n      }\n    });\n    return hasVisual ? ret : null;\n  };\n  /**\r\n   * Give order to visual types, considering colorSaturation, colorAlpha depends on color.\r\n   *\r\n   * @public\r\n   * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}\r\n   *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']\r\n   * @return {Array.<string>} Sorted visual types.\r\n   */\n\n\n  VisualMapping.prepareVisualTypes = function (visualTypes) {\n    if (zrUtil.isArray(visualTypes)) {\n      visualTypes = visualTypes.slice();\n    } else if (isObject(visualTypes)) {\n      var types_1 = [];\n      each(visualTypes, function (item, type) {\n        types_1.push(type);\n      });\n      visualTypes = types_1;\n    } else {\n      return [];\n    }\n\n    visualTypes.sort(function (type1, type2) {\n      // color should be front of colorSaturation, colorAlpha, ...\n      // symbol and symbolSize do not matter.\n      return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;\n    });\n    return visualTypes;\n  };\n  /**\r\n   * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.\r\n   * Other visuals are only depends on themself.\r\n   */\n\n\n  VisualMapping.dependsOn = function (visualType1, visualType2) {\n    return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;\n  };\n  /**\r\n   * @param value\r\n   * @param pieceList [{value: ..., interval: [min, max]}, ...]\r\n   *                         Always from small to big.\r\n   * @param findClosestWhenOutside Default to be false\r\n   * @return index\r\n   */\n\n\n  VisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {\n    var possibleI;\n    var abs = Infinity; // value has the higher priority.\n\n    for (var i = 0, len = pieceList.length; i < len; i++) {\n      var pieceValue = pieceList[i].value;\n\n      if (pieceValue != null) {\n        if (pieceValue === value // FIXME\n        // It is supposed to compare value according to value type of dimension,\n        // but currently value type can exactly be string or number.\n        // Compromise for numeric-like string (like '12'), especially\n        // in the case that visualMap.categories is ['22', '33'].\n        || zrUtil.isString(pieceValue) && pieceValue === value + '') {\n          return i;\n        }\n\n        findClosestWhenOutside && updatePossible(pieceValue, i);\n      }\n    }\n\n    for (var i = 0, len = pieceList.length; i < len; i++) {\n      var piece = pieceList[i];\n      var interval = piece.interval;\n      var close_1 = piece.close;\n\n      if (interval) {\n        if (interval[0] === -Infinity) {\n          if (littleThan(close_1[1], value, interval[1])) {\n            return i;\n          }\n        } else if (interval[1] === Infinity) {\n          if (littleThan(close_1[0], interval[0], value)) {\n            return i;\n          }\n        } else if (littleThan(close_1[0], interval[0], value) && littleThan(close_1[1], value, interval[1])) {\n          return i;\n        }\n\n        findClosestWhenOutside && updatePossible(interval[0], i);\n        findClosestWhenOutside && updatePossible(interval[1], i);\n      }\n    }\n\n    if (findClosestWhenOutside) {\n      return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;\n    }\n\n    function updatePossible(val, index) {\n      var newAbs = Math.abs(val - value);\n\n      if (newAbs < abs) {\n        abs = newAbs;\n        possibleI = index;\n      }\n    }\n  };\n\n  VisualMapping.visualHandlers = {\n    color: {\n      applyVisual: makeApplyVisual('color'),\n      getColorMapper: function getColorMapper() {\n        var thisOption = this.option;\n        return zrUtil.bind(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {\n          !isNormalized && (value = this._normalizeData(value));\n          return doMapCategory.call(this, value);\n        } : function (value, isNormalized, out) {\n          // If output rgb array\n          // which will be much faster and useful in pixel manipulation\n          var returnRGBArray = !!out;\n          !isNormalized && (value = this._normalizeData(value));\n          out = zrColor.fastLerp(value, thisOption.parsedVisual, out);\n          return returnRGBArray ? out : zrColor.stringify(out, 'rgba');\n        }, this);\n      },\n      _normalizedToVisual: {\n        linear: function linear(normalized) {\n          return zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n        },\n        category: doMapCategory,\n        piecewise: function piecewise(normalized, value) {\n          var result = getSpecifiedVisual.call(this, value);\n\n          if (result == null) {\n            result = zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n          }\n\n          return result;\n        },\n        fixed: doMapFixed\n      }\n    },\n    colorHue: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, value);\n    }),\n    colorSaturation: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, null, value);\n    }),\n    colorLightness: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, null, null, value);\n    }),\n    colorAlpha: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyAlpha(color, value);\n    }),\n    decal: {\n      applyVisual: makeApplyVisual('decal'),\n      _normalizedToVisual: {\n        linear: null,\n        category: doMapCategory,\n        piecewise: null,\n        fixed: null\n      }\n    },\n    opacity: {\n      applyVisual: makeApplyVisual('opacity'),\n      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n    },\n    liftZ: {\n      applyVisual: makeApplyVisual('liftZ'),\n      _normalizedToVisual: {\n        linear: doMapFixed,\n        category: doMapFixed,\n        piecewise: doMapFixed,\n        fixed: doMapFixed\n      }\n    },\n    symbol: {\n      applyVisual: function applyVisual(value, getter, setter) {\n        var symbolCfg = this.mapValueToVisual(value);\n        setter('symbol', symbolCfg);\n      },\n      _normalizedToVisual: {\n        linear: doMapToArray,\n        category: doMapCategory,\n        piecewise: function piecewise(normalized, value) {\n          var result = getSpecifiedVisual.call(this, value);\n\n          if (result == null) {\n            result = doMapToArray.call(this, normalized);\n          }\n\n          return result;\n        },\n        fixed: doMapFixed\n      }\n    },\n    symbolSize: {\n      applyVisual: makeApplyVisual('symbolSize'),\n      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n    }\n  };\n  return VisualMapping;\n}();\n\nfunction preprocessForPiecewise(thisOption) {\n  var pieceList = thisOption.pieceList;\n  thisOption.hasSpecialVisual = false;\n  zrUtil.each(pieceList, function (piece, index) {\n    piece.originIndex = index; // piece.visual is \"result visual value\" but not\n    // a visual range, so it does not need to be normalized.\n\n    if (piece.visual != null) {\n      thisOption.hasSpecialVisual = true;\n    }\n  });\n}\n\nfunction preprocessForSpecifiedCategory(thisOption) {\n  // Hash categories.\n  var categories = thisOption.categories;\n  var categoryMap = thisOption.categoryMap = {};\n  var visual = thisOption.visual;\n  each(categories, function (cate, index) {\n    categoryMap[cate] = index;\n  }); // Process visual map input.\n\n  if (!zrUtil.isArray(visual)) {\n    var visualArr_1 = [];\n\n    if (zrUtil.isObject(visual)) {\n      each(visual, function (v, cate) {\n        var index = categoryMap[cate];\n        visualArr_1[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;\n      });\n    } else {\n      // Is primary type, represents default visual.\n      visualArr_1[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;\n    }\n\n    visual = setVisualToOption(thisOption, visualArr_1);\n  } // Remove categories that has no visual,\n  // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.\n\n\n  for (var i = categories.length - 1; i >= 0; i--) {\n    if (visual[i] == null) {\n      delete categoryMap[categories[i]];\n      categories.pop();\n    }\n  }\n}\n\nfunction normalizeVisualRange(thisOption, isCategory) {\n  var visual = thisOption.visual;\n  var visualArr = [];\n\n  if (zrUtil.isObject(visual)) {\n    each(visual, function (v) {\n      visualArr.push(v);\n    });\n  } else if (visual != null) {\n    visualArr.push(visual);\n  }\n\n  var doNotNeedPair = {\n    color: 1,\n    symbol: 1\n  };\n\n  if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {\n    // Do not care visualArr.length === 0, which is illegal.\n    visualArr[1] = visualArr[0];\n  }\n\n  setVisualToOption(thisOption, visualArr);\n}\n\nfunction makePartialColorVisualHandler(applyValue) {\n  return {\n    applyVisual: function applyVisual(value, getter, setter) {\n      // Only used in HSL\n      var colorChannel = this.mapValueToVisual(value); // Must not be array value\n\n      setter('color', applyValue(getter('color'), colorChannel));\n    },\n    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n  };\n}\n\nfunction doMapToArray(normalized) {\n  var visual = this.option.visual;\n  return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {}; // TODO {}?\n}\n\nfunction makeApplyVisual(visualType) {\n  return function (value, getter, setter) {\n    setter(visualType, this.mapValueToVisual(value));\n  };\n}\n\nfunction doMapCategory(normalized) {\n  var visual = this.option.visual;\n  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];\n}\n\nfunction doMapFixed() {\n  // visual will be convert to array.\n  return this.option.visual[0];\n}\n/**\r\n * Create mapped to numeric visual\r\n */\n\n\nfunction createNormalizedToNumericVisual(sourceExtent) {\n  return {\n    linear: function linear(normalized) {\n      return linearMap(normalized, sourceExtent, this.option.visual, true);\n    },\n    category: doMapCategory,\n    piecewise: function piecewise(normalized, value) {\n      var result = getSpecifiedVisual.call(this, value);\n\n      if (result == null) {\n        result = linearMap(normalized, sourceExtent, this.option.visual, true);\n      }\n\n      return result;\n    },\n    fixed: doMapFixed\n  };\n}\n\nfunction getSpecifiedVisual(value) {\n  var thisOption = this.option;\n  var pieceList = thisOption.pieceList;\n\n  if (thisOption.hasSpecialVisual) {\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);\n    var piece = pieceList[pieceIndex];\n\n    if (piece && piece.visual) {\n      return piece.visual[this.type];\n    }\n  }\n}\n\nfunction setVisualToOption(thisOption, visualArr) {\n  thisOption.visual = visualArr;\n\n  if (thisOption.type === 'color') {\n    thisOption.parsedVisual = zrUtil.map(visualArr, function (item) {\n      var color = zrColor.parse(item);\n\n      if (!color && process.env.NODE_ENV !== 'production') {\n        warn(\"'\" + item + \"' is an illegal color, fallback to '#000000'\", true);\n      }\n\n      return color || [0, 0, 0, 1];\n    });\n  }\n\n  return visualArr;\n}\n/**\r\n * Normalizers by mapping methods.\r\n */\n\n\nvar normalizers = {\n  linear: function linear(value) {\n    return linearMap(value, this.option.dataExtent, [0, 1], true);\n  },\n  piecewise: function piecewise(value) {\n    var pieceList = this.option.pieceList;\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);\n\n    if (pieceIndex != null) {\n      return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);\n    }\n  },\n  category: function category(value) {\n    var index = this.option.categories ? this.option.categoryMap[value] : value; // ordinal value\n\n    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;\n  },\n  fixed: zrUtil.noop\n};\n\nfunction littleThan(close, a, b) {\n  return close ? a <= b : a < b;\n}\n\nexport default VisualMapping;","map":{"version":3,"sources":["F:/Desktop/繁星教育/TH资料/two_hours_front/node_modules/echarts/lib/visual/VisualMapping.js"],"names":["zrUtil","zrColor","linearMap","warn","each","isObject","CATEGORY_DEFAULT_VISUAL_INDEX","VisualMapping","option","mappingMethod","visualType","type","thisOption","clone","_normalizeData","normalizers","visualHandler","visualHandlers","applyVisual","getColorMapper","_normalizedToVisual","normalizeVisualRange","preprocessForPiecewise","categories","preprocessForSpecifiedCategory","assert","dataExtent","prototype","mapValueToVisual","value","normalized","getNormalizer","bind","listVisualTypes","keys","isValidType","hasOwnProperty","eachVisual","visual","callback","context","call","mapVisual","isPrimary","newVisual","isArray","v","key","newVal","retrieveVisuals","obj","ret","hasVisual","h","prepareVisualTypes","visualTypes","slice","types_1","item","push","sort","type1","type2","indexOf","dependsOn","visualType1","visualType2","findPieceIndex","pieceList","findClosestWhenOutside","possibleI","abs","Infinity","i","len","length","pieceValue","isString","updatePossible","piece","interval","close_1","close","littleThan","val","index","newAbs","Math","color","makeApplyVisual","isNormalized","doMapCategory","out","returnRGBArray","fastLerp","parsedVisual","stringify","linear","category","piecewise","result","getSpecifiedVisual","fixed","doMapFixed","colorHue","makePartialColorVisualHandler","modifyHSL","colorSaturation","colorLightness","colorAlpha","modifyAlpha","decal","opacity","createNormalizedToNumericVisual","liftZ","symbol","getter","setter","symbolCfg","doMapToArray","symbolSize","hasSpecialVisual","originIndex","categoryMap","cate","visualArr_1","setVisualToOption","pop","isCategory","visualArr","doNotNeedPair","applyValue","colorChannel","round","loop","sourceExtent","pieceIndex","map","parse","process","env","NODE_ENV","noop","a","b"],"mappings":";;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,KAAKA,MAAZ,MAAwB,0BAAxB;AACA,OAAO,KAAKC,OAAZ,MAAyB,2BAAzB;AACA,SAASC,SAAT,QAA0B,mBAA1B;AACA,SAASC,IAAT,QAAqB,gBAArB;AACA,IAAIC,IAAI,GAAGJ,MAAM,CAACI,IAAlB;AACA,IAAIC,QAAQ,GAAGL,MAAM,CAACK,QAAtB;AACA,IAAIC,6BAA6B,GAAG,CAAC,CAArC;;AAEA,IAAIC,aAAa;AACjB;AACA,YAAY;AACV,WAASA,aAAT,CAAuBC,MAAvB,EAA+B;AAC7B,QAAIC,aAAa,GAAGD,MAAM,CAACC,aAA3B;AACA,QAAIC,UAAU,GAAGF,MAAM,CAACG,IAAxB;AACA,QAAIC,UAAU,GAAG,KAAKJ,MAAL,GAAcR,MAAM,CAACa,KAAP,CAAaL,MAAb,CAA/B;AACA,SAAKG,IAAL,GAAYD,UAAZ;AACA,SAAKD,aAAL,GAAqBA,aAArB;AACA,SAAKK,cAAL,GAAsBC,WAAW,CAACN,aAAD,CAAjC;AACA,QAAIO,aAAa,GAAGT,aAAa,CAACU,cAAd,CAA6BP,UAA7B,CAApB;AACA,SAAKQ,WAAL,GAAmBF,aAAa,CAACE,WAAjC;AACA,SAAKC,cAAL,GAAsBH,aAAa,CAACG,cAApC;AACA,SAAKC,mBAAL,GAA2BJ,aAAa,CAACI,mBAAd,CAAkCX,aAAlC,CAA3B;;AAEA,QAAIA,aAAa,KAAK,WAAtB,EAAmC;AACjCY,MAAAA,oBAAoB,CAACT,UAAD,CAApB;AACAU,MAAAA,sBAAsB,CAACV,UAAD,CAAtB;AACD,KAHD,MAGO,IAAIH,aAAa,KAAK,UAAtB,EAAkC;AACvCG,MAAAA,UAAU,CAACW,UAAX,GAAwBC,8BAA8B,CAACZ,UAAD,CAAtD,CAAmE;AACnE;AADA,QAEES,oBAAoB,CAACT,UAAD,EAAa,IAAb,CAFtB;AAGD,KAJM,MAIA;AACL;AACAZ,MAAAA,MAAM,CAACyB,MAAP,CAAchB,aAAa,KAAK,QAAlB,IAA8BG,UAAU,CAACc,UAAvD;AACAL,MAAAA,oBAAoB,CAACT,UAAD,CAApB;AACD;AACF;;AAEDL,EAAAA,aAAa,CAACoB,SAAd,CAAwBC,gBAAxB,GAA2C,UAAUC,KAAV,EAAiB;AAC1D,QAAIC,UAAU,GAAG,KAAKhB,cAAL,CAAoBe,KAApB,CAAjB;;AAEA,WAAO,KAAKT,mBAAL,CAAyBU,UAAzB,EAAqCD,KAArC,CAAP;AACD,GAJD;;AAMAtB,EAAAA,aAAa,CAACoB,SAAd,CAAwBI,aAAxB,GAAwC,YAAY;AAClD,WAAO/B,MAAM,CAACgC,IAAP,CAAY,KAAKlB,cAAjB,EAAiC,IAAjC,CAAP;AACD,GAFD;AAGA;AACF;AACA;AACA;AACA;AACA;;;AAGEP,EAAAA,aAAa,CAAC0B,eAAd,GAAgC,YAAY;AAC1C,WAAOjC,MAAM,CAACkC,IAAP,CAAY3B,aAAa,CAACU,cAA1B,CAAP;AACD,GAFD,CA5CU,CA8CP;AACH;AACA;AACA;AACA;AACA;;AAEA;AACF;AACA;;;AAGEV,EAAAA,aAAa,CAAC4B,WAAd,GAA4B,UAAUzB,UAAV,EAAsB;AAChD,WAAOH,aAAa,CAACU,cAAd,CAA6BmB,cAA7B,CAA4C1B,UAA5C,CAAP;AACD,GAFD;AAGA;AACF;AACA;AACA;;;AAGEH,EAAAA,aAAa,CAAC8B,UAAd,GAA2B,UAAUC,MAAV,EAAkBC,QAAlB,EAA4BC,OAA5B,EAAqC;AAC9D,QAAIxC,MAAM,CAACK,QAAP,CAAgBiC,MAAhB,CAAJ,EAA6B;AAC3BtC,MAAAA,MAAM,CAACI,IAAP,CAAYkC,MAAZ,EAAoBC,QAApB,EAA8BC,OAA9B;AACD,KAFD,MAEO;AACLD,MAAAA,QAAQ,CAACE,IAAT,CAAcD,OAAd,EAAuBF,MAAvB;AACD;AACF,GAND;;AAQA/B,EAAAA,aAAa,CAACmC,SAAd,GAA0B,UAAUJ,MAAV,EAAkBC,QAAlB,EAA4BC,OAA5B,EAAqC;AAC7D,QAAIG,SAAJ;AACA,QAAIC,SAAS,GAAG5C,MAAM,CAAC6C,OAAP,CAAeP,MAAf,IAAyB,EAAzB,GAA8BtC,MAAM,CAACK,QAAP,CAAgBiC,MAAhB,IAA0B,EAA1B,IAAgCK,SAAS,GAAG,IAAZ,EAAkB,IAAlD,CAA9C;AACApC,IAAAA,aAAa,CAAC8B,UAAd,CAAyBC,MAAzB,EAAiC,UAAUQ,CAAV,EAAaC,GAAb,EAAkB;AACjD,UAAIC,MAAM,GAAGT,QAAQ,CAACE,IAAT,CAAcD,OAAd,EAAuBM,CAAvB,EAA0BC,GAA1B,CAAb;AACAJ,MAAAA,SAAS,GAAGC,SAAS,GAAGI,MAAf,GAAwBJ,SAAS,CAACG,GAAD,CAAT,GAAiBC,MAAlD;AACD,KAHD;AAIA,WAAOJ,SAAP;AACD,GARD;AASA;AACF;AACA;;;AAGErC,EAAAA,aAAa,CAAC0C,eAAd,GAAgC,UAAUC,GAAV,EAAe;AAC7C,QAAIC,GAAG,GAAG,EAAV;AACA,QAAIC,SAAJ;AACAF,IAAAA,GAAG,IAAI9C,IAAI,CAACG,aAAa,CAACU,cAAf,EAA+B,UAAUoC,CAAV,EAAa3C,UAAb,EAAyB;AACjE,UAAIwC,GAAG,CAACd,cAAJ,CAAmB1B,UAAnB,CAAJ,EAAoC;AAClCyC,QAAAA,GAAG,CAACzC,UAAD,CAAH,GAAkBwC,GAAG,CAACxC,UAAD,CAArB;AACA0C,QAAAA,SAAS,GAAG,IAAZ;AACD;AACF,KALU,CAAX;AAMA,WAAOA,SAAS,GAAGD,GAAH,GAAS,IAAzB;AACD,GAVD;AAWA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGE5C,EAAAA,aAAa,CAAC+C,kBAAd,GAAmC,UAAUC,WAAV,EAAuB;AACxD,QAAIvD,MAAM,CAAC6C,OAAP,CAAeU,WAAf,CAAJ,EAAiC;AAC/BA,MAAAA,WAAW,GAAGA,WAAW,CAACC,KAAZ,EAAd;AACD,KAFD,MAEO,IAAInD,QAAQ,CAACkD,WAAD,CAAZ,EAA2B;AAChC,UAAIE,OAAO,GAAG,EAAd;AACArD,MAAAA,IAAI,CAACmD,WAAD,EAAc,UAAUG,IAAV,EAAgB/C,IAAhB,EAAsB;AACtC8C,QAAAA,OAAO,CAACE,IAAR,CAAahD,IAAb;AACD,OAFG,CAAJ;AAGA4C,MAAAA,WAAW,GAAGE,OAAd;AACD,KANM,MAMA;AACL,aAAO,EAAP;AACD;;AAEDF,IAAAA,WAAW,CAACK,IAAZ,CAAiB,UAAUC,KAAV,EAAiBC,KAAjB,EAAwB;AACvC;AACA;AACA,aAAOA,KAAK,KAAK,OAAV,IAAqBD,KAAK,KAAK,OAA/B,IAA0CA,KAAK,CAACE,OAAN,CAAc,OAAd,MAA2B,CAArE,GAAyE,CAAzE,GAA6E,CAAC,CAArF;AACD,KAJD;AAKA,WAAOR,WAAP;AACD,GAnBD;AAoBA;AACF;AACA;AACA;;;AAGEhD,EAAAA,aAAa,CAACyD,SAAd,GAA0B,UAAUC,WAAV,EAAuBC,WAAvB,EAAoC;AAC5D,WAAOA,WAAW,KAAK,OAAhB,GAA0B,CAAC,EAAED,WAAW,IAAIA,WAAW,CAACF,OAAZ,CAAoBG,WAApB,MAAqC,CAAtD,CAA3B,GAAsFD,WAAW,KAAKC,WAA7G;AACD,GAFD;AAGA;AACF;AACA;AACA;AACA;AACA;AACA;;;AAGE3D,EAAAA,aAAa,CAAC4D,cAAd,GAA+B,UAAUtC,KAAV,EAAiBuC,SAAjB,EAA4BC,sBAA5B,EAAoD;AACjF,QAAIC,SAAJ;AACA,QAAIC,GAAG,GAAGC,QAAV,CAFiF,CAE7D;;AAEpB,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGN,SAAS,CAACO,MAAhC,EAAwCF,CAAC,GAAGC,GAA5C,EAAiDD,CAAC,EAAlD,EAAsD;AACpD,UAAIG,UAAU,GAAGR,SAAS,CAACK,CAAD,CAAT,CAAa5C,KAA9B;;AAEA,UAAI+C,UAAU,IAAI,IAAlB,EAAwB;AACtB,YAAIA,UAAU,KAAK/C,KAAf,CAAqB;AACzB;AACA;AACA;AACA;AAJI,WAKD7B,MAAM,CAAC6E,QAAP,CAAgBD,UAAhB,KAA+BA,UAAU,KAAK/C,KAAK,GAAG,EALzD,EAK6D;AAC3D,iBAAO4C,CAAP;AACD;;AAEDJ,QAAAA,sBAAsB,IAAIS,cAAc,CAACF,UAAD,EAAaH,CAAb,CAAxC;AACD;AACF;;AAED,SAAK,IAAIA,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGN,SAAS,CAACO,MAAhC,EAAwCF,CAAC,GAAGC,GAA5C,EAAiDD,CAAC,EAAlD,EAAsD;AACpD,UAAIM,KAAK,GAAGX,SAAS,CAACK,CAAD,CAArB;AACA,UAAIO,QAAQ,GAAGD,KAAK,CAACC,QAArB;AACA,UAAIC,OAAO,GAAGF,KAAK,CAACG,KAApB;;AAEA,UAAIF,QAAJ,EAAc;AACZ,YAAIA,QAAQ,CAAC,CAAD,CAAR,KAAgB,CAACR,QAArB,EAA+B;AAC7B,cAAIW,UAAU,CAACF,OAAO,CAAC,CAAD,CAAR,EAAapD,KAAb,EAAoBmD,QAAQ,CAAC,CAAD,CAA5B,CAAd,EAAgD;AAC9C,mBAAOP,CAAP;AACD;AACF,SAJD,MAIO,IAAIO,QAAQ,CAAC,CAAD,CAAR,KAAgBR,QAApB,EAA8B;AACnC,cAAIW,UAAU,CAACF,OAAO,CAAC,CAAD,CAAR,EAAaD,QAAQ,CAAC,CAAD,CAArB,EAA0BnD,KAA1B,CAAd,EAAgD;AAC9C,mBAAO4C,CAAP;AACD;AACF,SAJM,MAIA,IAAIU,UAAU,CAACF,OAAO,CAAC,CAAD,CAAR,EAAaD,QAAQ,CAAC,CAAD,CAArB,EAA0BnD,KAA1B,CAAV,IAA8CsD,UAAU,CAACF,OAAO,CAAC,CAAD,CAAR,EAAapD,KAAb,EAAoBmD,QAAQ,CAAC,CAAD,CAA5B,CAA5D,EAA8F;AACnG,iBAAOP,CAAP;AACD;;AAEDJ,QAAAA,sBAAsB,IAAIS,cAAc,CAACE,QAAQ,CAAC,CAAD,CAAT,EAAcP,CAAd,CAAxC;AACAJ,QAAAA,sBAAsB,IAAIS,cAAc,CAACE,QAAQ,CAAC,CAAD,CAAT,EAAcP,CAAd,CAAxC;AACD;AACF;;AAED,QAAIJ,sBAAJ,EAA4B;AAC1B,aAAOxC,KAAK,KAAK2C,QAAV,GAAqBJ,SAAS,CAACO,MAAV,GAAmB,CAAxC,GAA4C9C,KAAK,KAAK,CAAC2C,QAAX,GAAsB,CAAtB,GAA0BF,SAA7E;AACD;;AAED,aAASQ,cAAT,CAAwBM,GAAxB,EAA6BC,KAA7B,EAAoC;AAClC,UAAIC,MAAM,GAAGC,IAAI,CAAChB,GAAL,CAASa,GAAG,GAAGvD,KAAf,CAAb;;AAEA,UAAIyD,MAAM,GAAGf,GAAb,EAAkB;AAChBA,QAAAA,GAAG,GAAGe,MAAN;AACAhB,QAAAA,SAAS,GAAGe,KAAZ;AACD;AACF;AACF,GAxDD;;AA0DA9E,EAAAA,aAAa,CAACU,cAAd,GAA+B;AAC7BuE,IAAAA,KAAK,EAAE;AACLtE,MAAAA,WAAW,EAAEuE,eAAe,CAAC,OAAD,CADvB;AAELtE,MAAAA,cAAc,EAAE,0BAAY;AAC1B,YAAIP,UAAU,GAAG,KAAKJ,MAAtB;AACA,eAAOR,MAAM,CAACgC,IAAP,CAAYpB,UAAU,CAACH,aAAX,KAA6B,UAA7B,GAA0C,UAAUoB,KAAV,EAAiB6D,YAAjB,EAA+B;AAC1F,WAACA,YAAD,KAAkB7D,KAAK,GAAG,KAAKf,cAAL,CAAoBe,KAApB,CAA1B;AACA,iBAAO8D,aAAa,CAAClD,IAAd,CAAmB,IAAnB,EAAyBZ,KAAzB,CAAP;AACD,SAHkB,GAGf,UAAUA,KAAV,EAAiB6D,YAAjB,EAA+BE,GAA/B,EAAoC;AACtC;AACA;AACA,cAAIC,cAAc,GAAG,CAAC,CAACD,GAAvB;AACA,WAACF,YAAD,KAAkB7D,KAAK,GAAG,KAAKf,cAAL,CAAoBe,KAApB,CAA1B;AACA+D,UAAAA,GAAG,GAAG3F,OAAO,CAAC6F,QAAR,CAAiBjE,KAAjB,EAAwBjB,UAAU,CAACmF,YAAnC,EAAiDH,GAAjD,CAAN;AACA,iBAAOC,cAAc,GAAGD,GAAH,GAAS3F,OAAO,CAAC+F,SAAR,CAAkBJ,GAAlB,EAAuB,MAAvB,CAA9B;AACD,SAVM,EAUJ,IAVI,CAAP;AAWD,OAfI;AAgBLxE,MAAAA,mBAAmB,EAAE;AACnB6E,QAAAA,MAAM,EAAE,gBAAUnE,UAAV,EAAsB;AAC5B,iBAAO7B,OAAO,CAAC+F,SAAR,CAAkB/F,OAAO,CAAC6F,QAAR,CAAiBhE,UAAjB,EAA6B,KAAKtB,MAAL,CAAYuF,YAAzC,CAAlB,EAA0E,MAA1E,CAAP;AACD,SAHkB;AAInBG,QAAAA,QAAQ,EAAEP,aAJS;AAKnBQ,QAAAA,SAAS,EAAE,mBAAUrE,UAAV,EAAsBD,KAAtB,EAA6B;AACtC,cAAIuE,MAAM,GAAGC,kBAAkB,CAAC5D,IAAnB,CAAwB,IAAxB,EAA8BZ,KAA9B,CAAb;;AAEA,cAAIuE,MAAM,IAAI,IAAd,EAAoB;AAClBA,YAAAA,MAAM,GAAGnG,OAAO,CAAC+F,SAAR,CAAkB/F,OAAO,CAAC6F,QAAR,CAAiBhE,UAAjB,EAA6B,KAAKtB,MAAL,CAAYuF,YAAzC,CAAlB,EAA0E,MAA1E,CAAT;AACD;;AAED,iBAAOK,MAAP;AACD,SAbkB;AAcnBE,QAAAA,KAAK,EAAEC;AAdY;AAhBhB,KADsB;AAkC7BC,IAAAA,QAAQ,EAAEC,6BAA6B,CAAC,UAAUjB,KAAV,EAAiB3D,KAAjB,EAAwB;AAC9D,aAAO5B,OAAO,CAACyG,SAAR,CAAkBlB,KAAlB,EAAyB3D,KAAzB,CAAP;AACD,KAFsC,CAlCV;AAqC7B8E,IAAAA,eAAe,EAAEF,6BAA6B,CAAC,UAAUjB,KAAV,EAAiB3D,KAAjB,EAAwB;AACrE,aAAO5B,OAAO,CAACyG,SAAR,CAAkBlB,KAAlB,EAAyB,IAAzB,EAA+B3D,KAA/B,CAAP;AACD,KAF6C,CArCjB;AAwC7B+E,IAAAA,cAAc,EAAEH,6BAA6B,CAAC,UAAUjB,KAAV,EAAiB3D,KAAjB,EAAwB;AACpE,aAAO5B,OAAO,CAACyG,SAAR,CAAkBlB,KAAlB,EAAyB,IAAzB,EAA+B,IAA/B,EAAqC3D,KAArC,CAAP;AACD,KAF4C,CAxChB;AA2C7BgF,IAAAA,UAAU,EAAEJ,6BAA6B,CAAC,UAAUjB,KAAV,EAAiB3D,KAAjB,EAAwB;AAChE,aAAO5B,OAAO,CAAC6G,WAAR,CAAoBtB,KAApB,EAA2B3D,KAA3B,CAAP;AACD,KAFwC,CA3CZ;AA8C7BkF,IAAAA,KAAK,EAAE;AACL7F,MAAAA,WAAW,EAAEuE,eAAe,CAAC,OAAD,CADvB;AAELrE,MAAAA,mBAAmB,EAAE;AACnB6E,QAAAA,MAAM,EAAE,IADW;AAEnBC,QAAAA,QAAQ,EAAEP,aAFS;AAGnBQ,QAAAA,SAAS,EAAE,IAHQ;AAInBG,QAAAA,KAAK,EAAE;AAJY;AAFhB,KA9CsB;AAuD7BU,IAAAA,OAAO,EAAE;AACP9F,MAAAA,WAAW,EAAEuE,eAAe,CAAC,SAAD,CADrB;AAEPrE,MAAAA,mBAAmB,EAAE6F,+BAA+B,CAAC,CAAC,CAAD,EAAI,CAAJ,CAAD;AAF7C,KAvDoB;AA2D7BC,IAAAA,KAAK,EAAE;AACLhG,MAAAA,WAAW,EAAEuE,eAAe,CAAC,OAAD,CADvB;AAELrE,MAAAA,mBAAmB,EAAE;AACnB6E,QAAAA,MAAM,EAAEM,UADW;AAEnBL,QAAAA,QAAQ,EAAEK,UAFS;AAGnBJ,QAAAA,SAAS,EAAEI,UAHQ;AAInBD,QAAAA,KAAK,EAAEC;AAJY;AAFhB,KA3DsB;AAoE7BY,IAAAA,MAAM,EAAE;AACNjG,MAAAA,WAAW,EAAE,qBAAUW,KAAV,EAAiBuF,MAAjB,EAAyBC,MAAzB,EAAiC;AAC5C,YAAIC,SAAS,GAAG,KAAK1F,gBAAL,CAAsBC,KAAtB,CAAhB;AACAwF,QAAAA,MAAM,CAAC,QAAD,EAAWC,SAAX,CAAN;AACD,OAJK;AAKNlG,MAAAA,mBAAmB,EAAE;AACnB6E,QAAAA,MAAM,EAAEsB,YADW;AAEnBrB,QAAAA,QAAQ,EAAEP,aAFS;AAGnBQ,QAAAA,SAAS,EAAE,mBAAUrE,UAAV,EAAsBD,KAAtB,EAA6B;AACtC,cAAIuE,MAAM,GAAGC,kBAAkB,CAAC5D,IAAnB,CAAwB,IAAxB,EAA8BZ,KAA9B,CAAb;;AAEA,cAAIuE,MAAM,IAAI,IAAd,EAAoB;AAClBA,YAAAA,MAAM,GAAGmB,YAAY,CAAC9E,IAAb,CAAkB,IAAlB,EAAwBX,UAAxB,CAAT;AACD;;AAED,iBAAOsE,MAAP;AACD,SAXkB;AAYnBE,QAAAA,KAAK,EAAEC;AAZY;AALf,KApEqB;AAwF7BiB,IAAAA,UAAU,EAAE;AACVtG,MAAAA,WAAW,EAAEuE,eAAe,CAAC,YAAD,CADlB;AAEVrE,MAAAA,mBAAmB,EAAE6F,+BAA+B,CAAC,CAAC,CAAD,EAAI,CAAJ,CAAD;AAF1C;AAxFiB,GAA/B;AA6FA,SAAO1G,aAAP;AACD,CA5SD,EAFA;;AAgTA,SAASe,sBAAT,CAAgCV,UAAhC,EAA4C;AAC1C,MAAIwD,SAAS,GAAGxD,UAAU,CAACwD,SAA3B;AACAxD,EAAAA,UAAU,CAAC6G,gBAAX,GAA8B,KAA9B;AACAzH,EAAAA,MAAM,CAACI,IAAP,CAAYgE,SAAZ,EAAuB,UAAUW,KAAV,EAAiBM,KAAjB,EAAwB;AAC7CN,IAAAA,KAAK,CAAC2C,WAAN,GAAoBrC,KAApB,CAD6C,CAClB;AAC3B;;AAEA,QAAIN,KAAK,CAACzC,MAAN,IAAgB,IAApB,EAA0B;AACxB1B,MAAAA,UAAU,CAAC6G,gBAAX,GAA8B,IAA9B;AACD;AACF,GAPD;AAQD;;AAED,SAASjG,8BAAT,CAAwCZ,UAAxC,EAAoD;AAClD;AACA,MAAIW,UAAU,GAAGX,UAAU,CAACW,UAA5B;AACA,MAAIoG,WAAW,GAAG/G,UAAU,CAAC+G,WAAX,GAAyB,EAA3C;AACA,MAAIrF,MAAM,GAAG1B,UAAU,CAAC0B,MAAxB;AACAlC,EAAAA,IAAI,CAACmB,UAAD,EAAa,UAAUqG,IAAV,EAAgBvC,KAAhB,EAAuB;AACtCsC,IAAAA,WAAW,CAACC,IAAD,CAAX,GAAoBvC,KAApB;AACD,GAFG,CAAJ,CALkD,CAO9C;;AAEJ,MAAI,CAACrF,MAAM,CAAC6C,OAAP,CAAeP,MAAf,CAAL,EAA6B;AAC3B,QAAIuF,WAAW,GAAG,EAAlB;;AAEA,QAAI7H,MAAM,CAACK,QAAP,CAAgBiC,MAAhB,CAAJ,EAA6B;AAC3BlC,MAAAA,IAAI,CAACkC,MAAD,EAAS,UAAUQ,CAAV,EAAa8E,IAAb,EAAmB;AAC9B,YAAIvC,KAAK,GAAGsC,WAAW,CAACC,IAAD,CAAvB;AACAC,QAAAA,WAAW,CAACxC,KAAK,IAAI,IAAT,GAAgBA,KAAhB,GAAwB/E,6BAAzB,CAAX,GAAqEwC,CAArE;AACD,OAHG,CAAJ;AAID,KALD,MAKO;AACL;AACA+E,MAAAA,WAAW,CAACvH,6BAAD,CAAX,GAA6CgC,MAA7C;AACD;;AAEDA,IAAAA,MAAM,GAAGwF,iBAAiB,CAAClH,UAAD,EAAaiH,WAAb,CAA1B;AACD,GAvBiD,CAuBhD;AACF;;;AAGA,OAAK,IAAIpD,CAAC,GAAGlD,UAAU,CAACoD,MAAX,GAAoB,CAAjC,EAAoCF,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C,EAAiD;AAC/C,QAAInC,MAAM,CAACmC,CAAD,CAAN,IAAa,IAAjB,EAAuB;AACrB,aAAOkD,WAAW,CAACpG,UAAU,CAACkD,CAAD,CAAX,CAAlB;AACAlD,MAAAA,UAAU,CAACwG,GAAX;AACD;AACF;AACF;;AAED,SAAS1G,oBAAT,CAA8BT,UAA9B,EAA0CoH,UAA1C,EAAsD;AACpD,MAAI1F,MAAM,GAAG1B,UAAU,CAAC0B,MAAxB;AACA,MAAI2F,SAAS,GAAG,EAAhB;;AAEA,MAAIjI,MAAM,CAACK,QAAP,CAAgBiC,MAAhB,CAAJ,EAA6B;AAC3BlC,IAAAA,IAAI,CAACkC,MAAD,EAAS,UAAUQ,CAAV,EAAa;AACxBmF,MAAAA,SAAS,CAACtE,IAAV,CAAeb,CAAf;AACD,KAFG,CAAJ;AAGD,GAJD,MAIO,IAAIR,MAAM,IAAI,IAAd,EAAoB;AACzB2F,IAAAA,SAAS,CAACtE,IAAV,CAAerB,MAAf;AACD;;AAED,MAAI4F,aAAa,GAAG;AAClB1C,IAAAA,KAAK,EAAE,CADW;AAElB2B,IAAAA,MAAM,EAAE;AAFU,GAApB;;AAKA,MAAI,CAACa,UAAD,IAAeC,SAAS,CAACtD,MAAV,KAAqB,CAApC,IAAyC,CAACuD,aAAa,CAAC9F,cAAd,CAA6BxB,UAAU,CAACD,IAAxC,CAA9C,EAA6F;AAC3F;AACAsH,IAAAA,SAAS,CAAC,CAAD,CAAT,GAAeA,SAAS,CAAC,CAAD,CAAxB;AACD;;AAEDH,EAAAA,iBAAiB,CAAClH,UAAD,EAAaqH,SAAb,CAAjB;AACD;;AAED,SAASxB,6BAAT,CAAuC0B,UAAvC,EAAmD;AACjD,SAAO;AACLjH,IAAAA,WAAW,EAAE,qBAAUW,KAAV,EAAiBuF,MAAjB,EAAyBC,MAAzB,EAAiC;AAC5C;AACA,UAAIe,YAAY,GAAG,KAAKxG,gBAAL,CAAsBC,KAAtB,CAAnB,CAF4C,CAEK;;AAEjDwF,MAAAA,MAAM,CAAC,OAAD,EAAUc,UAAU,CAACf,MAAM,CAAC,OAAD,CAAP,EAAkBgB,YAAlB,CAApB,CAAN;AACD,KANI;AAOLhH,IAAAA,mBAAmB,EAAE6F,+BAA+B,CAAC,CAAC,CAAD,EAAI,CAAJ,CAAD;AAP/C,GAAP;AASD;;AAED,SAASM,YAAT,CAAsBzF,UAAtB,EAAkC;AAChC,MAAIQ,MAAM,GAAG,KAAK9B,MAAL,CAAY8B,MAAzB;AACA,SAAOA,MAAM,CAACiD,IAAI,CAAC8C,KAAL,CAAWnI,SAAS,CAAC4B,UAAD,EAAa,CAAC,CAAD,EAAI,CAAJ,CAAb,EAAqB,CAAC,CAAD,EAAIQ,MAAM,CAACqC,MAAP,GAAgB,CAApB,CAArB,EAA6C,IAA7C,CAApB,CAAD,CAAN,IAAmF,EAA1F,CAFgC,CAE8D;AAC/F;;AAED,SAASc,eAAT,CAAyB/E,UAAzB,EAAqC;AACnC,SAAO,UAAUmB,KAAV,EAAiBuF,MAAjB,EAAyBC,MAAzB,EAAiC;AACtCA,IAAAA,MAAM,CAAC3G,UAAD,EAAa,KAAKkB,gBAAL,CAAsBC,KAAtB,CAAb,CAAN;AACD,GAFD;AAGD;;AAED,SAAS8D,aAAT,CAAuB7D,UAAvB,EAAmC;AACjC,MAAIQ,MAAM,GAAG,KAAK9B,MAAL,CAAY8B,MAAzB;AACA,SAAOA,MAAM,CAAC,KAAK9B,MAAL,CAAY8H,IAAZ,IAAoBxG,UAAU,KAAKxB,6BAAnC,GAAmEwB,UAAU,GAAGQ,MAAM,CAACqC,MAAvF,GAAgG7C,UAAjG,CAAb;AACD;;AAED,SAASyE,UAAT,GAAsB;AACpB;AACA,SAAO,KAAK/F,MAAL,CAAY8B,MAAZ,CAAmB,CAAnB,CAAP;AACD;AACD;AACA;AACA;;;AAGA,SAAS2E,+BAAT,CAAyCsB,YAAzC,EAAuD;AACrD,SAAO;AACLtC,IAAAA,MAAM,EAAE,gBAAUnE,UAAV,EAAsB;AAC5B,aAAO5B,SAAS,CAAC4B,UAAD,EAAayG,YAAb,EAA2B,KAAK/H,MAAL,CAAY8B,MAAvC,EAA+C,IAA/C,CAAhB;AACD,KAHI;AAIL4D,IAAAA,QAAQ,EAAEP,aAJL;AAKLQ,IAAAA,SAAS,EAAE,mBAAUrE,UAAV,EAAsBD,KAAtB,EAA6B;AACtC,UAAIuE,MAAM,GAAGC,kBAAkB,CAAC5D,IAAnB,CAAwB,IAAxB,EAA8BZ,KAA9B,CAAb;;AAEA,UAAIuE,MAAM,IAAI,IAAd,EAAoB;AAClBA,QAAAA,MAAM,GAAGlG,SAAS,CAAC4B,UAAD,EAAayG,YAAb,EAA2B,KAAK/H,MAAL,CAAY8B,MAAvC,EAA+C,IAA/C,CAAlB;AACD;;AAED,aAAO8D,MAAP;AACD,KAbI;AAcLE,IAAAA,KAAK,EAAEC;AAdF,GAAP;AAgBD;;AAED,SAASF,kBAAT,CAA4BxE,KAA5B,EAAmC;AACjC,MAAIjB,UAAU,GAAG,KAAKJ,MAAtB;AACA,MAAI4D,SAAS,GAAGxD,UAAU,CAACwD,SAA3B;;AAEA,MAAIxD,UAAU,CAAC6G,gBAAf,EAAiC;AAC/B,QAAIe,UAAU,GAAGjI,aAAa,CAAC4D,cAAd,CAA6BtC,KAA7B,EAAoCuC,SAApC,CAAjB;AACA,QAAIW,KAAK,GAAGX,SAAS,CAACoE,UAAD,CAArB;;AAEA,QAAIzD,KAAK,IAAIA,KAAK,CAACzC,MAAnB,EAA2B;AACzB,aAAOyC,KAAK,CAACzC,MAAN,CAAa,KAAK3B,IAAlB,CAAP;AACD;AACF;AACF;;AAED,SAASmH,iBAAT,CAA2BlH,UAA3B,EAAuCqH,SAAvC,EAAkD;AAChDrH,EAAAA,UAAU,CAAC0B,MAAX,GAAoB2F,SAApB;;AAEA,MAAIrH,UAAU,CAACD,IAAX,KAAoB,OAAxB,EAAiC;AAC/BC,IAAAA,UAAU,CAACmF,YAAX,GAA0B/F,MAAM,CAACyI,GAAP,CAAWR,SAAX,EAAsB,UAAUvE,IAAV,EAAgB;AAC9D,UAAI8B,KAAK,GAAGvF,OAAO,CAACyI,KAAR,CAAchF,IAAd,CAAZ;;AAEA,UAAI,CAAC8B,KAAD,IAAUmD,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAvC,EAAqD;AACnD1I,QAAAA,IAAI,CAAC,MAAMuD,IAAN,GAAa,8CAAd,EAA8D,IAA9D,CAAJ;AACD;;AAED,aAAO8B,KAAK,IAAI,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAhB;AACD,KARyB,CAA1B;AASD;;AAED,SAAOyC,SAAP;AACD;AACD;AACA;AACA;;;AAGA,IAAIlH,WAAW,GAAG;AAChBkF,EAAAA,MAAM,EAAE,gBAAUpE,KAAV,EAAiB;AACvB,WAAO3B,SAAS,CAAC2B,KAAD,EAAQ,KAAKrB,MAAL,CAAYkB,UAApB,EAAgC,CAAC,CAAD,EAAI,CAAJ,CAAhC,EAAwC,IAAxC,CAAhB;AACD,GAHe;AAIhByE,EAAAA,SAAS,EAAE,mBAAUtE,KAAV,EAAiB;AAC1B,QAAIuC,SAAS,GAAG,KAAK5D,MAAL,CAAY4D,SAA5B;AACA,QAAIoE,UAAU,GAAGjI,aAAa,CAAC4D,cAAd,CAA6BtC,KAA7B,EAAoCuC,SAApC,EAA+C,IAA/C,CAAjB;;AAEA,QAAIoE,UAAU,IAAI,IAAlB,EAAwB;AACtB,aAAOtI,SAAS,CAACsI,UAAD,EAAa,CAAC,CAAD,EAAIpE,SAAS,CAACO,MAAV,GAAmB,CAAvB,CAAb,EAAwC,CAAC,CAAD,EAAI,CAAJ,CAAxC,EAAgD,IAAhD,CAAhB;AACD;AACF,GAXe;AAYhBuB,EAAAA,QAAQ,EAAE,kBAAUrE,KAAV,EAAiB;AACzB,QAAIwD,KAAK,GAAG,KAAK7E,MAAL,CAAYe,UAAZ,GAAyB,KAAKf,MAAL,CAAYmH,WAAZ,CAAwB9F,KAAxB,CAAzB,GAA0DA,KAAtE,CADyB,CACoD;;AAE7E,WAAOwD,KAAK,IAAI,IAAT,GAAgB/E,6BAAhB,GAAgD+E,KAAvD;AACD,GAhBe;AAiBhBiB,EAAAA,KAAK,EAAEtG,MAAM,CAAC8I;AAjBE,CAAlB;;AAoBA,SAAS3D,UAAT,CAAoBD,KAApB,EAA2B6D,CAA3B,EAA8BC,CAA9B,EAAiC;AAC/B,SAAO9D,KAAK,GAAG6D,CAAC,IAAIC,CAAR,GAAYD,CAAC,GAAGC,CAA5B;AACD;;AAED,eAAezI,aAAf","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport * as zrColor from 'zrender/lib/tool/color.js';\nimport { linearMap } from '../util/number.js';\nimport { warn } from '../util/log.js';\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\nvar CATEGORY_DEFAULT_VISUAL_INDEX = -1;\n\nvar VisualMapping =\n/** @class */\nfunction () {\n  function VisualMapping(option) {\n    var mappingMethod = option.mappingMethod;\n    var visualType = option.type;\n    var thisOption = this.option = zrUtil.clone(option);\n    this.type = visualType;\n    this.mappingMethod = mappingMethod;\n    this._normalizeData = normalizers[mappingMethod];\n    var visualHandler = VisualMapping.visualHandlers[visualType];\n    this.applyVisual = visualHandler.applyVisual;\n    this.getColorMapper = visualHandler.getColorMapper;\n    this._normalizedToVisual = visualHandler._normalizedToVisual[mappingMethod];\n\n    if (mappingMethod === 'piecewise') {\n      normalizeVisualRange(thisOption);\n      preprocessForPiecewise(thisOption);\n    } else if (mappingMethod === 'category') {\n      thisOption.categories ? preprocessForSpecifiedCategory(thisOption) // categories is ordinal when thisOption.categories not specified,\n      // which need no more preprocess except normalize visual.\n      : normalizeVisualRange(thisOption, true);\n    } else {\n      // mappingMethod === 'linear' or 'fixed'\n      zrUtil.assert(mappingMethod !== 'linear' || thisOption.dataExtent);\n      normalizeVisualRange(thisOption);\n    }\n  }\n\n  VisualMapping.prototype.mapValueToVisual = function (value) {\n    var normalized = this._normalizeData(value);\n\n    return this._normalizedToVisual(normalized, value);\n  };\n\n  VisualMapping.prototype.getNormalizer = function () {\n    return zrUtil.bind(this._normalizeData, this);\n  };\n  /**\r\n   * List available visual types.\r\n   *\r\n   * @public\r\n   * @return {Array.<string>}\r\n   */\n\n\n  VisualMapping.listVisualTypes = function () {\n    return zrUtil.keys(VisualMapping.visualHandlers);\n  }; // /**\n  //  * @public\n  //  */\n  // static addVisualHandler(name, handler) {\n  //     visualHandlers[name] = handler;\n  // }\n\n  /**\r\n   * @public\r\n   */\n\n\n  VisualMapping.isValidType = function (visualType) {\n    return VisualMapping.visualHandlers.hasOwnProperty(visualType);\n  };\n  /**\r\n   * Convinent method.\r\n   * Visual can be Object or Array or primary type.\r\n   */\n\n\n  VisualMapping.eachVisual = function (visual, callback, context) {\n    if (zrUtil.isObject(visual)) {\n      zrUtil.each(visual, callback, context);\n    } else {\n      callback.call(context, visual);\n    }\n  };\n\n  VisualMapping.mapVisual = function (visual, callback, context) {\n    var isPrimary;\n    var newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = true, null);\n    VisualMapping.eachVisual(visual, function (v, key) {\n      var newVal = callback.call(context, v, key);\n      isPrimary ? newVisual = newVal : newVisual[key] = newVal;\n    });\n    return newVisual;\n  };\n  /**\r\n   * Retrieve visual properties from given object.\r\n   */\n\n\n  VisualMapping.retrieveVisuals = function (obj) {\n    var ret = {};\n    var hasVisual;\n    obj && each(VisualMapping.visualHandlers, function (h, visualType) {\n      if (obj.hasOwnProperty(visualType)) {\n        ret[visualType] = obj[visualType];\n        hasVisual = true;\n      }\n    });\n    return hasVisual ? ret : null;\n  };\n  /**\r\n   * Give order to visual types, considering colorSaturation, colorAlpha depends on color.\r\n   *\r\n   * @public\r\n   * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}\r\n   *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']\r\n   * @return {Array.<string>} Sorted visual types.\r\n   */\n\n\n  VisualMapping.prepareVisualTypes = function (visualTypes) {\n    if (zrUtil.isArray(visualTypes)) {\n      visualTypes = visualTypes.slice();\n    } else if (isObject(visualTypes)) {\n      var types_1 = [];\n      each(visualTypes, function (item, type) {\n        types_1.push(type);\n      });\n      visualTypes = types_1;\n    } else {\n      return [];\n    }\n\n    visualTypes.sort(function (type1, type2) {\n      // color should be front of colorSaturation, colorAlpha, ...\n      // symbol and symbolSize do not matter.\n      return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;\n    });\n    return visualTypes;\n  };\n  /**\r\n   * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.\r\n   * Other visuals are only depends on themself.\r\n   */\n\n\n  VisualMapping.dependsOn = function (visualType1, visualType2) {\n    return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;\n  };\n  /**\r\n   * @param value\r\n   * @param pieceList [{value: ..., interval: [min, max]}, ...]\r\n   *                         Always from small to big.\r\n   * @param findClosestWhenOutside Default to be false\r\n   * @return index\r\n   */\n\n\n  VisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {\n    var possibleI;\n    var abs = Infinity; // value has the higher priority.\n\n    for (var i = 0, len = pieceList.length; i < len; i++) {\n      var pieceValue = pieceList[i].value;\n\n      if (pieceValue != null) {\n        if (pieceValue === value // FIXME\n        // It is supposed to compare value according to value type of dimension,\n        // but currently value type can exactly be string or number.\n        // Compromise for numeric-like string (like '12'), especially\n        // in the case that visualMap.categories is ['22', '33'].\n        || zrUtil.isString(pieceValue) && pieceValue === value + '') {\n          return i;\n        }\n\n        findClosestWhenOutside && updatePossible(pieceValue, i);\n      }\n    }\n\n    for (var i = 0, len = pieceList.length; i < len; i++) {\n      var piece = pieceList[i];\n      var interval = piece.interval;\n      var close_1 = piece.close;\n\n      if (interval) {\n        if (interval[0] === -Infinity) {\n          if (littleThan(close_1[1], value, interval[1])) {\n            return i;\n          }\n        } else if (interval[1] === Infinity) {\n          if (littleThan(close_1[0], interval[0], value)) {\n            return i;\n          }\n        } else if (littleThan(close_1[0], interval[0], value) && littleThan(close_1[1], value, interval[1])) {\n          return i;\n        }\n\n        findClosestWhenOutside && updatePossible(interval[0], i);\n        findClosestWhenOutside && updatePossible(interval[1], i);\n      }\n    }\n\n    if (findClosestWhenOutside) {\n      return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;\n    }\n\n    function updatePossible(val, index) {\n      var newAbs = Math.abs(val - value);\n\n      if (newAbs < abs) {\n        abs = newAbs;\n        possibleI = index;\n      }\n    }\n  };\n\n  VisualMapping.visualHandlers = {\n    color: {\n      applyVisual: makeApplyVisual('color'),\n      getColorMapper: function () {\n        var thisOption = this.option;\n        return zrUtil.bind(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {\n          !isNormalized && (value = this._normalizeData(value));\n          return doMapCategory.call(this, value);\n        } : function (value, isNormalized, out) {\n          // If output rgb array\n          // which will be much faster and useful in pixel manipulation\n          var returnRGBArray = !!out;\n          !isNormalized && (value = this._normalizeData(value));\n          out = zrColor.fastLerp(value, thisOption.parsedVisual, out);\n          return returnRGBArray ? out : zrColor.stringify(out, 'rgba');\n        }, this);\n      },\n      _normalizedToVisual: {\n        linear: function (normalized) {\n          return zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n        },\n        category: doMapCategory,\n        piecewise: function (normalized, value) {\n          var result = getSpecifiedVisual.call(this, value);\n\n          if (result == null) {\n            result = zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n          }\n\n          return result;\n        },\n        fixed: doMapFixed\n      }\n    },\n    colorHue: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, value);\n    }),\n    colorSaturation: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, null, value);\n    }),\n    colorLightness: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, null, null, value);\n    }),\n    colorAlpha: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyAlpha(color, value);\n    }),\n    decal: {\n      applyVisual: makeApplyVisual('decal'),\n      _normalizedToVisual: {\n        linear: null,\n        category: doMapCategory,\n        piecewise: null,\n        fixed: null\n      }\n    },\n    opacity: {\n      applyVisual: makeApplyVisual('opacity'),\n      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n    },\n    liftZ: {\n      applyVisual: makeApplyVisual('liftZ'),\n      _normalizedToVisual: {\n        linear: doMapFixed,\n        category: doMapFixed,\n        piecewise: doMapFixed,\n        fixed: doMapFixed\n      }\n    },\n    symbol: {\n      applyVisual: function (value, getter, setter) {\n        var symbolCfg = this.mapValueToVisual(value);\n        setter('symbol', symbolCfg);\n      },\n      _normalizedToVisual: {\n        linear: doMapToArray,\n        category: doMapCategory,\n        piecewise: function (normalized, value) {\n          var result = getSpecifiedVisual.call(this, value);\n\n          if (result == null) {\n            result = doMapToArray.call(this, normalized);\n          }\n\n          return result;\n        },\n        fixed: doMapFixed\n      }\n    },\n    symbolSize: {\n      applyVisual: makeApplyVisual('symbolSize'),\n      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n    }\n  };\n  return VisualMapping;\n}();\n\nfunction preprocessForPiecewise(thisOption) {\n  var pieceList = thisOption.pieceList;\n  thisOption.hasSpecialVisual = false;\n  zrUtil.each(pieceList, function (piece, index) {\n    piece.originIndex = index; // piece.visual is \"result visual value\" but not\n    // a visual range, so it does not need to be normalized.\n\n    if (piece.visual != null) {\n      thisOption.hasSpecialVisual = true;\n    }\n  });\n}\n\nfunction preprocessForSpecifiedCategory(thisOption) {\n  // Hash categories.\n  var categories = thisOption.categories;\n  var categoryMap = thisOption.categoryMap = {};\n  var visual = thisOption.visual;\n  each(categories, function (cate, index) {\n    categoryMap[cate] = index;\n  }); // Process visual map input.\n\n  if (!zrUtil.isArray(visual)) {\n    var visualArr_1 = [];\n\n    if (zrUtil.isObject(visual)) {\n      each(visual, function (v, cate) {\n        var index = categoryMap[cate];\n        visualArr_1[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;\n      });\n    } else {\n      // Is primary type, represents default visual.\n      visualArr_1[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;\n    }\n\n    visual = setVisualToOption(thisOption, visualArr_1);\n  } // Remove categories that has no visual,\n  // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.\n\n\n  for (var i = categories.length - 1; i >= 0; i--) {\n    if (visual[i] == null) {\n      delete categoryMap[categories[i]];\n      categories.pop();\n    }\n  }\n}\n\nfunction normalizeVisualRange(thisOption, isCategory) {\n  var visual = thisOption.visual;\n  var visualArr = [];\n\n  if (zrUtil.isObject(visual)) {\n    each(visual, function (v) {\n      visualArr.push(v);\n    });\n  } else if (visual != null) {\n    visualArr.push(visual);\n  }\n\n  var doNotNeedPair = {\n    color: 1,\n    symbol: 1\n  };\n\n  if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {\n    // Do not care visualArr.length === 0, which is illegal.\n    visualArr[1] = visualArr[0];\n  }\n\n  setVisualToOption(thisOption, visualArr);\n}\n\nfunction makePartialColorVisualHandler(applyValue) {\n  return {\n    applyVisual: function (value, getter, setter) {\n      // Only used in HSL\n      var colorChannel = this.mapValueToVisual(value); // Must not be array value\n\n      setter('color', applyValue(getter('color'), colorChannel));\n    },\n    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n  };\n}\n\nfunction doMapToArray(normalized) {\n  var visual = this.option.visual;\n  return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {}; // TODO {}?\n}\n\nfunction makeApplyVisual(visualType) {\n  return function (value, getter, setter) {\n    setter(visualType, this.mapValueToVisual(value));\n  };\n}\n\nfunction doMapCategory(normalized) {\n  var visual = this.option.visual;\n  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];\n}\n\nfunction doMapFixed() {\n  // visual will be convert to array.\n  return this.option.visual[0];\n}\n/**\r\n * Create mapped to numeric visual\r\n */\n\n\nfunction createNormalizedToNumericVisual(sourceExtent) {\n  return {\n    linear: function (normalized) {\n      return linearMap(normalized, sourceExtent, this.option.visual, true);\n    },\n    category: doMapCategory,\n    piecewise: function (normalized, value) {\n      var result = getSpecifiedVisual.call(this, value);\n\n      if (result == null) {\n        result = linearMap(normalized, sourceExtent, this.option.visual, true);\n      }\n\n      return result;\n    },\n    fixed: doMapFixed\n  };\n}\n\nfunction getSpecifiedVisual(value) {\n  var thisOption = this.option;\n  var pieceList = thisOption.pieceList;\n\n  if (thisOption.hasSpecialVisual) {\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);\n    var piece = pieceList[pieceIndex];\n\n    if (piece && piece.visual) {\n      return piece.visual[this.type];\n    }\n  }\n}\n\nfunction setVisualToOption(thisOption, visualArr) {\n  thisOption.visual = visualArr;\n\n  if (thisOption.type === 'color') {\n    thisOption.parsedVisual = zrUtil.map(visualArr, function (item) {\n      var color = zrColor.parse(item);\n\n      if (!color && process.env.NODE_ENV !== 'production') {\n        warn(\"'\" + item + \"' is an illegal color, fallback to '#000000'\", true);\n      }\n\n      return color || [0, 0, 0, 1];\n    });\n  }\n\n  return visualArr;\n}\n/**\r\n * Normalizers by mapping methods.\r\n */\n\n\nvar normalizers = {\n  linear: function (value) {\n    return linearMap(value, this.option.dataExtent, [0, 1], true);\n  },\n  piecewise: function (value) {\n    var pieceList = this.option.pieceList;\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);\n\n    if (pieceIndex != null) {\n      return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);\n    }\n  },\n  category: function (value) {\n    var index = this.option.categories ? this.option.categoryMap[value] : value; // ordinal value\n\n    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;\n  },\n  fixed: zrUtil.noop\n};\n\nfunction littleThan(close, a, b) {\n  return close ? a <= b : a < b;\n}\n\nexport default VisualMapping;"]},"metadata":{},"sourceType":"module"}