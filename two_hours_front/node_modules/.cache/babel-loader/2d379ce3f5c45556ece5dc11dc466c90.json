{"ast":null,"code":"import \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport Clip from './Clip.js';\nimport * as color from '../tool/color.js';\nimport { eqNaN, extend, isArrayLike, isFunction, isGradientObject, isNumber, isString, keys, logError, map } from '../core/util.js';\nimport easingFuncs from './easing.js';\nimport { createCubicEasingFunc } from './cubicEasing.js';\nimport { isLinearGradient, isRadialGradient } from '../svg/helper.js';\n;\nvar arraySlice = Array.prototype.slice;\n\nfunction interpolateNumber(p0, p1, percent) {\n  return (p1 - p0) * percent + p0;\n}\n\nfunction interpolate1DArray(out, p0, p1, percent) {\n  var len = p0.length;\n\n  for (var i = 0; i < len; i++) {\n    out[i] = interpolateNumber(p0[i], p1[i], percent);\n  }\n\n  return out;\n}\n\nfunction interpolate2DArray(out, p0, p1, percent) {\n  var len = p0.length;\n  var len2 = len && p0[0].length;\n\n  for (var i = 0; i < len; i++) {\n    if (!out[i]) {\n      out[i] = [];\n    }\n\n    for (var j = 0; j < len2; j++) {\n      out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n    }\n  }\n\n  return out;\n}\n\nfunction add1DArray(out, p0, p1, sign) {\n  var len = p0.length;\n\n  for (var i = 0; i < len; i++) {\n    out[i] = p0[i] + p1[i] * sign;\n  }\n\n  return out;\n}\n\nfunction add2DArray(out, p0, p1, sign) {\n  var len = p0.length;\n  var len2 = len && p0[0].length;\n\n  for (var i = 0; i < len; i++) {\n    if (!out[i]) {\n      out[i] = [];\n    }\n\n    for (var j = 0; j < len2; j++) {\n      out[i][j] = p0[i][j] + p1[i][j] * sign;\n    }\n  }\n\n  return out;\n}\n\nfunction fillColorStops(val0, val1) {\n  var len0 = val0.length;\n  var len1 = val1.length;\n  var shorterArr = len0 > len1 ? val1 : val0;\n  var shorterLen = Math.min(len0, len1);\n  var last = shorterArr[shorterLen - 1] || {\n    color: [0, 0, 0, 0],\n    offset: 0\n  };\n\n  for (var i = shorterLen; i < Math.max(len0, len1); i++) {\n    shorterArr.push({\n      offset: last.offset,\n      color: last.color.slice()\n    });\n  }\n}\n\nfunction fillArray(val0, val1, arrDim) {\n  var arr0 = val0;\n  var arr1 = val1;\n\n  if (!arr0.push || !arr1.push) {\n    return;\n  }\n\n  var arr0Len = arr0.length;\n  var arr1Len = arr1.length;\n\n  if (arr0Len !== arr1Len) {\n    var isPreviousLarger = arr0Len > arr1Len;\n\n    if (isPreviousLarger) {\n      arr0.length = arr1Len;\n    } else {\n      for (var i = arr0Len; i < arr1Len; i++) {\n        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n      }\n    }\n  }\n\n  var len2 = arr0[0] && arr0[0].length;\n\n  for (var i = 0; i < arr0.length; i++) {\n    if (arrDim === 1) {\n      if (isNaN(arr0[i])) {\n        arr0[i] = arr1[i];\n      }\n    } else {\n      for (var j = 0; j < len2; j++) {\n        if (isNaN(arr0[i][j])) {\n          arr0[i][j] = arr1[i][j];\n        }\n      }\n    }\n  }\n}\n\nexport function cloneValue(value) {\n  if (isArrayLike(value)) {\n    var len = value.length;\n\n    if (isArrayLike(value[0])) {\n      var ret = [];\n\n      for (var i = 0; i < len; i++) {\n        ret.push(arraySlice.call(value[i]));\n      }\n\n      return ret;\n    }\n\n    return arraySlice.call(value);\n  }\n\n  return value;\n}\n\nfunction rgba2String(rgba) {\n  rgba[0] = Math.floor(rgba[0]) || 0;\n  rgba[1] = Math.floor(rgba[1]) || 0;\n  rgba[2] = Math.floor(rgba[2]) || 0;\n  rgba[3] = rgba[3] == null ? 1 : rgba[3];\n  return 'rgba(' + rgba.join(',') + ')';\n}\n\nfunction guessArrayDim(value) {\n  return isArrayLike(value && value[0]) ? 2 : 1;\n}\n\nvar VALUE_TYPE_NUMBER = 0;\nvar VALUE_TYPE_1D_ARRAY = 1;\nvar VALUE_TYPE_2D_ARRAY = 2;\nvar VALUE_TYPE_COLOR = 3;\nvar VALUE_TYPE_LINEAR_GRADIENT = 4;\nvar VALUE_TYPE_RADIAL_GRADIENT = 5;\nvar VALUE_TYPE_UNKOWN = 6;\n\nfunction isGradientValueType(valType) {\n  return valType === VALUE_TYPE_LINEAR_GRADIENT || valType === VALUE_TYPE_RADIAL_GRADIENT;\n}\n\nfunction isArrayValueType(valType) {\n  return valType === VALUE_TYPE_1D_ARRAY || valType === VALUE_TYPE_2D_ARRAY;\n}\n\nvar tmpRgba = [0, 0, 0, 0];\n\nvar Track = function () {\n  function Track(propName) {\n    this.keyframes = [];\n    this.discrete = false;\n    this._invalid = false;\n    this._needsSort = false;\n    this._lastFr = 0;\n    this._lastFrP = 0;\n    this.propName = propName;\n  }\n\n  Track.prototype.isFinished = function () {\n    return this._finished;\n  };\n\n  Track.prototype.setFinished = function () {\n    this._finished = true;\n\n    if (this._additiveTrack) {\n      this._additiveTrack.setFinished();\n    }\n  };\n\n  Track.prototype.needsAnimate = function () {\n    return this.keyframes.length >= 1;\n  };\n\n  Track.prototype.getAdditiveTrack = function () {\n    return this._additiveTrack;\n  };\n\n  Track.prototype.addKeyframe = function (time, rawValue, easing) {\n    this._needsSort = true;\n    var keyframes = this.keyframes;\n    var len = keyframes.length;\n    var discrete = false;\n    var valType = VALUE_TYPE_UNKOWN;\n    var value = rawValue;\n\n    if (isArrayLike(rawValue)) {\n      var arrayDim = guessArrayDim(rawValue);\n      valType = arrayDim;\n\n      if (arrayDim === 1 && !isNumber(rawValue[0]) || arrayDim === 2 && !isNumber(rawValue[0][0])) {\n        discrete = true;\n      }\n    } else {\n      if (isNumber(rawValue) && !eqNaN(rawValue)) {\n        valType = VALUE_TYPE_NUMBER;\n      } else if (isString(rawValue)) {\n        if (!isNaN(+rawValue)) {\n          valType = VALUE_TYPE_NUMBER;\n        } else {\n          var colorArray = color.parse(rawValue);\n\n          if (colorArray) {\n            value = colorArray;\n            valType = VALUE_TYPE_COLOR;\n          }\n        }\n      } else if (isGradientObject(rawValue)) {\n        var parsedGradient = extend({}, value);\n        parsedGradient.colorStops = map(rawValue.colorStops, function (colorStop) {\n          return {\n            offset: colorStop.offset,\n            color: color.parse(colorStop.color)\n          };\n        });\n\n        if (isLinearGradient(rawValue)) {\n          valType = VALUE_TYPE_LINEAR_GRADIENT;\n        } else if (isRadialGradient(rawValue)) {\n          valType = VALUE_TYPE_RADIAL_GRADIENT;\n        }\n\n        value = parsedGradient;\n      }\n    }\n\n    if (len === 0) {\n      this.valType = valType;\n    } else if (valType !== this.valType || valType === VALUE_TYPE_UNKOWN) {\n      discrete = true;\n    }\n\n    this.discrete = this.discrete || discrete;\n    var kf = {\n      time: time,\n      value: value,\n      rawValue: rawValue,\n      percent: 0\n    };\n\n    if (easing) {\n      kf.easing = easing;\n      kf.easingFunc = isFunction(easing) ? easing : easingFuncs[easing] || createCubicEasingFunc(easing);\n    }\n\n    keyframes.push(kf);\n    return kf;\n  };\n\n  Track.prototype.prepare = function (maxTime, additiveTrack) {\n    var kfs = this.keyframes;\n\n    if (this._needsSort) {\n      kfs.sort(function (a, b) {\n        return a.time - b.time;\n      });\n    }\n\n    var valType = this.valType;\n    var kfsLen = kfs.length;\n    var lastKf = kfs[kfsLen - 1];\n    var isDiscrete = this.discrete;\n    var isArr = isArrayValueType(valType);\n    var isGradient = isGradientValueType(valType);\n\n    for (var i = 0; i < kfsLen; i++) {\n      var kf = kfs[i];\n      var value = kf.value;\n      var lastValue = lastKf.value;\n      kf.percent = kf.time / maxTime;\n\n      if (!isDiscrete) {\n        if (isArr && i !== kfsLen - 1) {\n          fillArray(value, lastValue, valType);\n        } else if (isGradient) {\n          fillColorStops(value.colorStops, lastValue.colorStops);\n        }\n      }\n    }\n\n    if (!isDiscrete && valType !== VALUE_TYPE_RADIAL_GRADIENT && additiveTrack && this.needsAnimate() && additiveTrack.needsAnimate() && valType === additiveTrack.valType && !additiveTrack._finished) {\n      this._additiveTrack = additiveTrack;\n      var startValue = kfs[0].value;\n\n      for (var i = 0; i < kfsLen; i++) {\n        if (valType === VALUE_TYPE_NUMBER) {\n          kfs[i].additiveValue = kfs[i].value - startValue;\n        } else if (valType === VALUE_TYPE_COLOR) {\n          kfs[i].additiveValue = add1DArray([], kfs[i].value, startValue, -1);\n        } else if (isArrayValueType(valType)) {\n          kfs[i].additiveValue = valType === VALUE_TYPE_1D_ARRAY ? add1DArray([], kfs[i].value, startValue, -1) : add2DArray([], kfs[i].value, startValue, -1);\n        }\n      }\n    }\n  };\n\n  Track.prototype.step = function (target, percent) {\n    if (this._finished) {\n      return;\n    }\n\n    if (this._additiveTrack && this._additiveTrack._finished) {\n      this._additiveTrack = null;\n    }\n\n    var isAdditive = this._additiveTrack != null;\n    var valueKey = isAdditive ? 'additiveValue' : 'value';\n    var valType = this.valType;\n    var keyframes = this.keyframes;\n    var kfsNum = keyframes.length;\n    var propName = this.propName;\n    var isValueColor = valType === VALUE_TYPE_COLOR;\n    var frameIdx;\n    var lastFrame = this._lastFr;\n    var mathMin = Math.min;\n    var frame;\n    var nextFrame;\n\n    if (kfsNum === 1) {\n      frame = nextFrame = keyframes[0];\n    } else {\n      if (percent < 0) {\n        frameIdx = 0;\n      } else if (percent < this._lastFrP) {\n        var start = mathMin(lastFrame + 1, kfsNum - 1);\n\n        for (frameIdx = start; frameIdx >= 0; frameIdx--) {\n          if (keyframes[frameIdx].percent <= percent) {\n            break;\n          }\n        }\n\n        frameIdx = mathMin(frameIdx, kfsNum - 2);\n      } else {\n        for (frameIdx = lastFrame; frameIdx < kfsNum; frameIdx++) {\n          if (keyframes[frameIdx].percent > percent) {\n            break;\n          }\n        }\n\n        frameIdx = mathMin(frameIdx - 1, kfsNum - 2);\n      }\n\n      nextFrame = keyframes[frameIdx + 1];\n      frame = keyframes[frameIdx];\n    }\n\n    if (!(frame && nextFrame)) {\n      return;\n    }\n\n    this._lastFr = frameIdx;\n    this._lastFrP = percent;\n    var interval = nextFrame.percent - frame.percent;\n    var w = interval === 0 ? 1 : mathMin((percent - frame.percent) / interval, 1);\n\n    if (nextFrame.easingFunc) {\n      w = nextFrame.easingFunc(w);\n    }\n\n    var targetArr = isAdditive ? this._additiveValue : isValueColor ? tmpRgba : target[propName];\n\n    if ((isArrayValueType(valType) || isValueColor) && !targetArr) {\n      targetArr = this._additiveValue = [];\n    }\n\n    if (this.discrete) {\n      target[propName] = w < 1 ? frame.rawValue : nextFrame.rawValue;\n    } else if (isArrayValueType(valType)) {\n      valType === VALUE_TYPE_1D_ARRAY ? interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w) : interpolate2DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);\n    } else if (isGradientValueType(valType)) {\n      var val = frame[valueKey];\n      var nextVal_1 = nextFrame[valueKey];\n      var isLinearGradient_1 = valType === VALUE_TYPE_LINEAR_GRADIENT;\n      target[propName] = {\n        type: isLinearGradient_1 ? 'linear' : 'radial',\n        x: interpolateNumber(val.x, nextVal_1.x, w),\n        y: interpolateNumber(val.y, nextVal_1.y, w),\n        colorStops: map(val.colorStops, function (colorStop, idx) {\n          var nextColorStop = nextVal_1.colorStops[idx];\n          return {\n            offset: interpolateNumber(colorStop.offset, nextColorStop.offset, w),\n            color: rgba2String(interpolate1DArray([], colorStop.color, nextColorStop.color, w))\n          };\n        }),\n        global: nextVal_1.global\n      };\n\n      if (isLinearGradient_1) {\n        target[propName].x2 = interpolateNumber(val.x2, nextVal_1.x2, w);\n        target[propName].y2 = interpolateNumber(val.y2, nextVal_1.y2, w);\n      } else {\n        target[propName].r = interpolateNumber(val.r, nextVal_1.r, w);\n      }\n    } else if (isValueColor) {\n      interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);\n\n      if (!isAdditive) {\n        target[propName] = rgba2String(targetArr);\n      }\n    } else {\n      var value = interpolateNumber(frame[valueKey], nextFrame[valueKey], w);\n\n      if (isAdditive) {\n        this._additiveValue = value;\n      } else {\n        target[propName] = value;\n      }\n    }\n\n    if (isAdditive) {\n      this._addToTarget(target);\n    }\n  };\n\n  Track.prototype._addToTarget = function (target) {\n    var valType = this.valType;\n    var propName = this.propName;\n    var additiveValue = this._additiveValue;\n\n    if (valType === VALUE_TYPE_NUMBER) {\n      target[propName] = target[propName] + additiveValue;\n    } else if (valType === VALUE_TYPE_COLOR) {\n      color.parse(target[propName], tmpRgba);\n      add1DArray(tmpRgba, tmpRgba, additiveValue, 1);\n      target[propName] = rgba2String(tmpRgba);\n    } else if (valType === VALUE_TYPE_1D_ARRAY) {\n      add1DArray(target[propName], target[propName], additiveValue, 1);\n    } else if (valType === VALUE_TYPE_2D_ARRAY) {\n      add2DArray(target[propName], target[propName], additiveValue, 1);\n    }\n  };\n\n  return Track;\n}();\n\nvar Animator = function () {\n  function Animator(target, loop, allowDiscreteAnimation, additiveTo) {\n    this._tracks = {};\n    this._trackKeys = [];\n    this._maxTime = 0;\n    this._started = 0;\n    this._clip = null;\n    this._target = target;\n    this._loop = loop;\n\n    if (loop && additiveTo) {\n      logError('Can\\' use additive animation on looped animation.');\n      return;\n    }\n\n    this._additiveAnimators = additiveTo;\n    this._allowDiscrete = allowDiscreteAnimation;\n  }\n\n  Animator.prototype.getMaxTime = function () {\n    return this._maxTime;\n  };\n\n  Animator.prototype.getDelay = function () {\n    return this._delay;\n  };\n\n  Animator.prototype.getLoop = function () {\n    return this._loop;\n  };\n\n  Animator.prototype.getTarget = function () {\n    return this._target;\n  };\n\n  Animator.prototype.changeTarget = function (target) {\n    this._target = target;\n  };\n\n  Animator.prototype.when = function (time, props, easing) {\n    return this.whenWithKeys(time, props, keys(props), easing);\n  };\n\n  Animator.prototype.whenWithKeys = function (time, props, propNames, easing) {\n    var tracks = this._tracks;\n\n    for (var i = 0; i < propNames.length; i++) {\n      var propName = propNames[i];\n      var track = tracks[propName];\n\n      if (!track) {\n        track = tracks[propName] = new Track(propName);\n        var initialValue = void 0;\n\n        var additiveTrack = this._getAdditiveTrack(propName);\n\n        if (additiveTrack) {\n          var addtiveTrackKfs = additiveTrack.keyframes;\n          var lastFinalKf = addtiveTrackKfs[addtiveTrackKfs.length - 1];\n          initialValue = lastFinalKf && lastFinalKf.value;\n\n          if (additiveTrack.valType === VALUE_TYPE_COLOR && initialValue) {\n            initialValue = rgba2String(initialValue);\n          }\n        } else {\n          initialValue = this._target[propName];\n        }\n\n        if (initialValue == null) {\n          continue;\n        }\n\n        if (time > 0) {\n          track.addKeyframe(0, cloneValue(initialValue), easing);\n        }\n\n        this._trackKeys.push(propName);\n      }\n\n      track.addKeyframe(time, cloneValue(props[propName]), easing);\n    }\n\n    this._maxTime = Math.max(this._maxTime, time);\n    return this;\n  };\n\n  Animator.prototype.pause = function () {\n    this._clip.pause();\n\n    this._paused = true;\n  };\n\n  Animator.prototype.resume = function () {\n    this._clip.resume();\n\n    this._paused = false;\n  };\n\n  Animator.prototype.isPaused = function () {\n    return !!this._paused;\n  };\n\n  Animator.prototype.duration = function (duration) {\n    this._maxTime = duration;\n    this._force = true;\n    return this;\n  };\n\n  Animator.prototype._doneCallback = function () {\n    this._setTracksFinished();\n\n    this._clip = null;\n    var doneList = this._doneCbs;\n\n    if (doneList) {\n      var len = doneList.length;\n\n      for (var i = 0; i < len; i++) {\n        doneList[i].call(this);\n      }\n    }\n  };\n\n  Animator.prototype._abortedCallback = function () {\n    this._setTracksFinished();\n\n    var animation = this.animation;\n    var abortedList = this._abortedCbs;\n\n    if (animation) {\n      animation.removeClip(this._clip);\n    }\n\n    this._clip = null;\n\n    if (abortedList) {\n      for (var i = 0; i < abortedList.length; i++) {\n        abortedList[i].call(this);\n      }\n    }\n  };\n\n  Animator.prototype._setTracksFinished = function () {\n    var tracks = this._tracks;\n    var tracksKeys = this._trackKeys;\n\n    for (var i = 0; i < tracksKeys.length; i++) {\n      tracks[tracksKeys[i]].setFinished();\n    }\n  };\n\n  Animator.prototype._getAdditiveTrack = function (trackName) {\n    var additiveTrack;\n    var additiveAnimators = this._additiveAnimators;\n\n    if (additiveAnimators) {\n      for (var i = 0; i < additiveAnimators.length; i++) {\n        var track = additiveAnimators[i].getTrack(trackName);\n\n        if (track) {\n          additiveTrack = track;\n        }\n      }\n    }\n\n    return additiveTrack;\n  };\n\n  Animator.prototype.start = function (easing) {\n    if (this._started > 0) {\n      return;\n    }\n\n    this._started = 1;\n    var self = this;\n    var tracks = [];\n    var maxTime = this._maxTime || 0;\n\n    for (var i = 0; i < this._trackKeys.length; i++) {\n      var propName = this._trackKeys[i];\n      var track = this._tracks[propName];\n\n      var additiveTrack = this._getAdditiveTrack(propName);\n\n      var kfs = track.keyframes;\n      var kfsNum = kfs.length;\n      track.prepare(maxTime, additiveTrack);\n\n      if (track.needsAnimate()) {\n        if (!this._allowDiscrete && track.discrete) {\n          var lastKf = kfs[kfsNum - 1];\n\n          if (lastKf) {\n            self._target[track.propName] = lastKf.rawValue;\n          }\n\n          track.setFinished();\n        } else {\n          tracks.push(track);\n        }\n      }\n    }\n\n    if (tracks.length || this._force) {\n      var clip = new Clip({\n        life: maxTime,\n        loop: this._loop,\n        delay: this._delay || 0,\n        onframe: function onframe(percent) {\n          self._started = 2;\n          var additiveAnimators = self._additiveAnimators;\n\n          if (additiveAnimators) {\n            var stillHasAdditiveAnimator = false;\n\n            for (var i = 0; i < additiveAnimators.length; i++) {\n              if (additiveAnimators[i]._clip) {\n                stillHasAdditiveAnimator = true;\n                break;\n              }\n            }\n\n            if (!stillHasAdditiveAnimator) {\n              self._additiveAnimators = null;\n            }\n          }\n\n          for (var i = 0; i < tracks.length; i++) {\n            tracks[i].step(self._target, percent);\n          }\n\n          var onframeList = self._onframeCbs;\n\n          if (onframeList) {\n            for (var i = 0; i < onframeList.length; i++) {\n              onframeList[i](self._target, percent);\n            }\n          }\n        },\n        ondestroy: function ondestroy() {\n          self._doneCallback();\n        }\n      });\n      this._clip = clip;\n\n      if (this.animation) {\n        this.animation.addClip(clip);\n      }\n\n      if (easing) {\n        clip.setEasing(easing);\n      }\n    } else {\n      this._doneCallback();\n    }\n\n    return this;\n  };\n\n  Animator.prototype.stop = function (forwardToLast) {\n    if (!this._clip) {\n      return;\n    }\n\n    var clip = this._clip;\n\n    if (forwardToLast) {\n      clip.onframe(1);\n    }\n\n    this._abortedCallback();\n  };\n\n  Animator.prototype.delay = function (time) {\n    this._delay = time;\n    return this;\n  };\n\n  Animator.prototype.during = function (cb) {\n    if (cb) {\n      if (!this._onframeCbs) {\n        this._onframeCbs = [];\n      }\n\n      this._onframeCbs.push(cb);\n    }\n\n    return this;\n  };\n\n  Animator.prototype.done = function (cb) {\n    if (cb) {\n      if (!this._doneCbs) {\n        this._doneCbs = [];\n      }\n\n      this._doneCbs.push(cb);\n    }\n\n    return this;\n  };\n\n  Animator.prototype.aborted = function (cb) {\n    if (cb) {\n      if (!this._abortedCbs) {\n        this._abortedCbs = [];\n      }\n\n      this._abortedCbs.push(cb);\n    }\n\n    return this;\n  };\n\n  Animator.prototype.getClip = function () {\n    return this._clip;\n  };\n\n  Animator.prototype.getTrack = function (propName) {\n    return this._tracks[propName];\n  };\n\n  Animator.prototype.getTracks = function () {\n    var _this = this;\n\n    return map(this._trackKeys, function (key) {\n      return _this._tracks[key];\n    });\n  };\n\n  Animator.prototype.stopTracks = function (propNames, forwardToLast) {\n    if (!propNames.length || !this._clip) {\n      return true;\n    }\n\n    var tracks = this._tracks;\n    var tracksKeys = this._trackKeys;\n\n    for (var i = 0; i < propNames.length; i++) {\n      var track = tracks[propNames[i]];\n\n      if (track && !track.isFinished()) {\n        if (forwardToLast) {\n          track.step(this._target, 1);\n        } else if (this._started === 1) {\n          track.step(this._target, 0);\n        }\n\n        track.setFinished();\n      }\n    }\n\n    var allAborted = true;\n\n    for (var i = 0; i < tracksKeys.length; i++) {\n      if (!tracks[tracksKeys[i]].isFinished()) {\n        allAborted = false;\n        break;\n      }\n    }\n\n    if (allAborted) {\n      this._abortedCallback();\n    }\n\n    return allAborted;\n  };\n\n  Animator.prototype.saveTo = function (target, trackKeys, firstOrLast) {\n    if (!target) {\n      return;\n    }\n\n    trackKeys = trackKeys || this._trackKeys;\n\n    for (var i = 0; i < trackKeys.length; i++) {\n      var propName = trackKeys[i];\n      var track = this._tracks[propName];\n\n      if (!track || track.isFinished()) {\n        continue;\n      }\n\n      var kfs = track.keyframes;\n      var kf = kfs[firstOrLast ? 0 : kfs.length - 1];\n\n      if (kf) {\n        target[propName] = cloneValue(kf.rawValue);\n      }\n    }\n  };\n\n  Animator.prototype.__changeFinalValue = function (finalProps, trackKeys) {\n    trackKeys = trackKeys || keys(finalProps);\n\n    for (var i = 0; i < trackKeys.length; i++) {\n      var propName = trackKeys[i];\n      var track = this._tracks[propName];\n\n      if (!track) {\n        continue;\n      }\n\n      var kfs = track.keyframes;\n\n      if (kfs.length > 1) {\n        var lastKf = kfs.pop();\n        track.addKeyframe(lastKf.time, finalProps[propName]);\n        track.prepare(this._maxTime, track.getAdditiveTrack());\n      }\n    }\n  };\n\n  return Animator;\n}();\n\nexport default Animator;","map":{"version":3,"sources":["F:/Desktop/繁星教育/TH资料/two_hours_front/node_modules/zrender/lib/animation/Animator.js"],"names":["Clip","color","eqNaN","extend","isArrayLike","isFunction","isGradientObject","isNumber","isString","keys","logError","map","easingFuncs","createCubicEasingFunc","isLinearGradient","isRadialGradient","arraySlice","Array","prototype","slice","interpolateNumber","p0","p1","percent","interpolate1DArray","out","len","length","i","interpolate2DArray","len2","j","add1DArray","sign","add2DArray","fillColorStops","val0","val1","len0","len1","shorterArr","shorterLen","Math","min","last","offset","max","push","fillArray","arrDim","arr0","arr1","arr0Len","arr1Len","isPreviousLarger","call","isNaN","cloneValue","value","ret","rgba2String","rgba","floor","join","guessArrayDim","VALUE_TYPE_NUMBER","VALUE_TYPE_1D_ARRAY","VALUE_TYPE_2D_ARRAY","VALUE_TYPE_COLOR","VALUE_TYPE_LINEAR_GRADIENT","VALUE_TYPE_RADIAL_GRADIENT","VALUE_TYPE_UNKOWN","isGradientValueType","valType","isArrayValueType","tmpRgba","Track","propName","keyframes","discrete","_invalid","_needsSort","_lastFr","_lastFrP","isFinished","_finished","setFinished","_additiveTrack","needsAnimate","getAdditiveTrack","addKeyframe","time","rawValue","easing","arrayDim","colorArray","parse","parsedGradient","colorStops","colorStop","kf","easingFunc","prepare","maxTime","additiveTrack","kfs","sort","a","b","kfsLen","lastKf","isDiscrete","isArr","isGradient","lastValue","startValue","additiveValue","step","target","isAdditive","valueKey","kfsNum","isValueColor","frameIdx","lastFrame","mathMin","frame","nextFrame","start","interval","w","targetArr","_additiveValue","val","nextVal_1","isLinearGradient_1","type","x","y","idx","nextColorStop","global","x2","y2","r","_addToTarget","Animator","loop","allowDiscreteAnimation","additiveTo","_tracks","_trackKeys","_maxTime","_started","_clip","_target","_loop","_additiveAnimators","_allowDiscrete","getMaxTime","getDelay","_delay","getLoop","getTarget","changeTarget","when","props","whenWithKeys","propNames","tracks","track","initialValue","_getAdditiveTrack","addtiveTrackKfs","lastFinalKf","pause","_paused","resume","isPaused","duration","_force","_doneCallback","_setTracksFinished","doneList","_doneCbs","_abortedCallback","animation","abortedList","_abortedCbs","removeClip","tracksKeys","trackName","additiveAnimators","getTrack","self","clip","life","delay","onframe","stillHasAdditiveAnimator","onframeList","_onframeCbs","ondestroy","addClip","setEasing","stop","forwardToLast","during","cb","done","aborted","getClip","getTracks","_this","key","stopTracks","allAborted","saveTo","trackKeys","firstOrLast","__changeFinalValue","finalProps","pop"],"mappings":"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","sourcesContent":["import Clip from './Clip.js';\nimport * as color from '../tool/color.js';\nimport { eqNaN, extend, isArrayLike, isFunction, isGradientObject, isNumber, isString, keys, logError, map } from '../core/util.js';\nimport easingFuncs from './easing.js';\nimport { createCubicEasingFunc } from './cubicEasing.js';\nimport { isLinearGradient, isRadialGradient } from '../svg/helper.js';\n;\nvar arraySlice = Array.prototype.slice;\nfunction interpolateNumber(p0, p1, percent) {\n    return (p1 - p0) * percent + p0;\n}\nfunction interpolate1DArray(out, p0, p1, percent) {\n    var len = p0.length;\n    for (var i = 0; i < len; i++) {\n        out[i] = interpolateNumber(p0[i], p1[i], percent);\n    }\n    return out;\n}\nfunction interpolate2DArray(out, p0, p1, percent) {\n    var len = p0.length;\n    var len2 = len && p0[0].length;\n    for (var i = 0; i < len; i++) {\n        if (!out[i]) {\n            out[i] = [];\n        }\n        for (var j = 0; j < len2; j++) {\n            out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n        }\n    }\n    return out;\n}\nfunction add1DArray(out, p0, p1, sign) {\n    var len = p0.length;\n    for (var i = 0; i < len; i++) {\n        out[i] = p0[i] + p1[i] * sign;\n    }\n    return out;\n}\nfunction add2DArray(out, p0, p1, sign) {\n    var len = p0.length;\n    var len2 = len && p0[0].length;\n    for (var i = 0; i < len; i++) {\n        if (!out[i]) {\n            out[i] = [];\n        }\n        for (var j = 0; j < len2; j++) {\n            out[i][j] = p0[i][j] + p1[i][j] * sign;\n        }\n    }\n    return out;\n}\nfunction fillColorStops(val0, val1) {\n    var len0 = val0.length;\n    var len1 = val1.length;\n    var shorterArr = len0 > len1 ? val1 : val0;\n    var shorterLen = Math.min(len0, len1);\n    var last = shorterArr[shorterLen - 1] || { color: [0, 0, 0, 0], offset: 0 };\n    for (var i = shorterLen; i < Math.max(len0, len1); i++) {\n        shorterArr.push({\n            offset: last.offset,\n            color: last.color.slice()\n        });\n    }\n}\nfunction fillArray(val0, val1, arrDim) {\n    var arr0 = val0;\n    var arr1 = val1;\n    if (!arr0.push || !arr1.push) {\n        return;\n    }\n    var arr0Len = arr0.length;\n    var arr1Len = arr1.length;\n    if (arr0Len !== arr1Len) {\n        var isPreviousLarger = arr0Len > arr1Len;\n        if (isPreviousLarger) {\n            arr0.length = arr1Len;\n        }\n        else {\n            for (var i = arr0Len; i < arr1Len; i++) {\n                arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n            }\n        }\n    }\n    var len2 = arr0[0] && arr0[0].length;\n    for (var i = 0; i < arr0.length; i++) {\n        if (arrDim === 1) {\n            if (isNaN(arr0[i])) {\n                arr0[i] = arr1[i];\n            }\n        }\n        else {\n            for (var j = 0; j < len2; j++) {\n                if (isNaN(arr0[i][j])) {\n                    arr0[i][j] = arr1[i][j];\n                }\n            }\n        }\n    }\n}\nexport function cloneValue(value) {\n    if (isArrayLike(value)) {\n        var len = value.length;\n        if (isArrayLike(value[0])) {\n            var ret = [];\n            for (var i = 0; i < len; i++) {\n                ret.push(arraySlice.call(value[i]));\n            }\n            return ret;\n        }\n        return arraySlice.call(value);\n    }\n    return value;\n}\nfunction rgba2String(rgba) {\n    rgba[0] = Math.floor(rgba[0]) || 0;\n    rgba[1] = Math.floor(rgba[1]) || 0;\n    rgba[2] = Math.floor(rgba[2]) || 0;\n    rgba[3] = rgba[3] == null ? 1 : rgba[3];\n    return 'rgba(' + rgba.join(',') + ')';\n}\nfunction guessArrayDim(value) {\n    return isArrayLike(value && value[0]) ? 2 : 1;\n}\nvar VALUE_TYPE_NUMBER = 0;\nvar VALUE_TYPE_1D_ARRAY = 1;\nvar VALUE_TYPE_2D_ARRAY = 2;\nvar VALUE_TYPE_COLOR = 3;\nvar VALUE_TYPE_LINEAR_GRADIENT = 4;\nvar VALUE_TYPE_RADIAL_GRADIENT = 5;\nvar VALUE_TYPE_UNKOWN = 6;\nfunction isGradientValueType(valType) {\n    return valType === VALUE_TYPE_LINEAR_GRADIENT || valType === VALUE_TYPE_RADIAL_GRADIENT;\n}\nfunction isArrayValueType(valType) {\n    return valType === VALUE_TYPE_1D_ARRAY || valType === VALUE_TYPE_2D_ARRAY;\n}\nvar tmpRgba = [0, 0, 0, 0];\nvar Track = (function () {\n    function Track(propName) {\n        this.keyframes = [];\n        this.discrete = false;\n        this._invalid = false;\n        this._needsSort = false;\n        this._lastFr = 0;\n        this._lastFrP = 0;\n        this.propName = propName;\n    }\n    Track.prototype.isFinished = function () {\n        return this._finished;\n    };\n    Track.prototype.setFinished = function () {\n        this._finished = true;\n        if (this._additiveTrack) {\n            this._additiveTrack.setFinished();\n        }\n    };\n    Track.prototype.needsAnimate = function () {\n        return this.keyframes.length >= 1;\n    };\n    Track.prototype.getAdditiveTrack = function () {\n        return this._additiveTrack;\n    };\n    Track.prototype.addKeyframe = function (time, rawValue, easing) {\n        this._needsSort = true;\n        var keyframes = this.keyframes;\n        var len = keyframes.length;\n        var discrete = false;\n        var valType = VALUE_TYPE_UNKOWN;\n        var value = rawValue;\n        if (isArrayLike(rawValue)) {\n            var arrayDim = guessArrayDim(rawValue);\n            valType = arrayDim;\n            if (arrayDim === 1 && !isNumber(rawValue[0])\n                || arrayDim === 2 && !isNumber(rawValue[0][0])) {\n                discrete = true;\n            }\n        }\n        else {\n            if (isNumber(rawValue) && !eqNaN(rawValue)) {\n                valType = VALUE_TYPE_NUMBER;\n            }\n            else if (isString(rawValue)) {\n                if (!isNaN(+rawValue)) {\n                    valType = VALUE_TYPE_NUMBER;\n                }\n                else {\n                    var colorArray = color.parse(rawValue);\n                    if (colorArray) {\n                        value = colorArray;\n                        valType = VALUE_TYPE_COLOR;\n                    }\n                }\n            }\n            else if (isGradientObject(rawValue)) {\n                var parsedGradient = extend({}, value);\n                parsedGradient.colorStops = map(rawValue.colorStops, function (colorStop) { return ({\n                    offset: colorStop.offset,\n                    color: color.parse(colorStop.color)\n                }); });\n                if (isLinearGradient(rawValue)) {\n                    valType = VALUE_TYPE_LINEAR_GRADIENT;\n                }\n                else if (isRadialGradient(rawValue)) {\n                    valType = VALUE_TYPE_RADIAL_GRADIENT;\n                }\n                value = parsedGradient;\n            }\n        }\n        if (len === 0) {\n            this.valType = valType;\n        }\n        else if (valType !== this.valType || valType === VALUE_TYPE_UNKOWN) {\n            discrete = true;\n        }\n        this.discrete = this.discrete || discrete;\n        var kf = {\n            time: time,\n            value: value,\n            rawValue: rawValue,\n            percent: 0\n        };\n        if (easing) {\n            kf.easing = easing;\n            kf.easingFunc = isFunction(easing)\n                ? easing\n                : easingFuncs[easing] || createCubicEasingFunc(easing);\n        }\n        keyframes.push(kf);\n        return kf;\n    };\n    Track.prototype.prepare = function (maxTime, additiveTrack) {\n        var kfs = this.keyframes;\n        if (this._needsSort) {\n            kfs.sort(function (a, b) {\n                return a.time - b.time;\n            });\n        }\n        var valType = this.valType;\n        var kfsLen = kfs.length;\n        var lastKf = kfs[kfsLen - 1];\n        var isDiscrete = this.discrete;\n        var isArr = isArrayValueType(valType);\n        var isGradient = isGradientValueType(valType);\n        for (var i = 0; i < kfsLen; i++) {\n            var kf = kfs[i];\n            var value = kf.value;\n            var lastValue = lastKf.value;\n            kf.percent = kf.time / maxTime;\n            if (!isDiscrete) {\n                if (isArr && i !== kfsLen - 1) {\n                    fillArray(value, lastValue, valType);\n                }\n                else if (isGradient) {\n                    fillColorStops(value.colorStops, lastValue.colorStops);\n                }\n            }\n        }\n        if (!isDiscrete\n            && valType !== VALUE_TYPE_RADIAL_GRADIENT\n            && additiveTrack\n            && this.needsAnimate()\n            && additiveTrack.needsAnimate()\n            && valType === additiveTrack.valType\n            && !additiveTrack._finished) {\n            this._additiveTrack = additiveTrack;\n            var startValue = kfs[0].value;\n            for (var i = 0; i < kfsLen; i++) {\n                if (valType === VALUE_TYPE_NUMBER) {\n                    kfs[i].additiveValue = kfs[i].value - startValue;\n                }\n                else if (valType === VALUE_TYPE_COLOR) {\n                    kfs[i].additiveValue =\n                        add1DArray([], kfs[i].value, startValue, -1);\n                }\n                else if (isArrayValueType(valType)) {\n                    kfs[i].additiveValue = valType === VALUE_TYPE_1D_ARRAY\n                        ? add1DArray([], kfs[i].value, startValue, -1)\n                        : add2DArray([], kfs[i].value, startValue, -1);\n                }\n            }\n        }\n    };\n    Track.prototype.step = function (target, percent) {\n        if (this._finished) {\n            return;\n        }\n        if (this._additiveTrack && this._additiveTrack._finished) {\n            this._additiveTrack = null;\n        }\n        var isAdditive = this._additiveTrack != null;\n        var valueKey = isAdditive ? 'additiveValue' : 'value';\n        var valType = this.valType;\n        var keyframes = this.keyframes;\n        var kfsNum = keyframes.length;\n        var propName = this.propName;\n        var isValueColor = valType === VALUE_TYPE_COLOR;\n        var frameIdx;\n        var lastFrame = this._lastFr;\n        var mathMin = Math.min;\n        var frame;\n        var nextFrame;\n        if (kfsNum === 1) {\n            frame = nextFrame = keyframes[0];\n        }\n        else {\n            if (percent < 0) {\n                frameIdx = 0;\n            }\n            else if (percent < this._lastFrP) {\n                var start = mathMin(lastFrame + 1, kfsNum - 1);\n                for (frameIdx = start; frameIdx >= 0; frameIdx--) {\n                    if (keyframes[frameIdx].percent <= percent) {\n                        break;\n                    }\n                }\n                frameIdx = mathMin(frameIdx, kfsNum - 2);\n            }\n            else {\n                for (frameIdx = lastFrame; frameIdx < kfsNum; frameIdx++) {\n                    if (keyframes[frameIdx].percent > percent) {\n                        break;\n                    }\n                }\n                frameIdx = mathMin(frameIdx - 1, kfsNum - 2);\n            }\n            nextFrame = keyframes[frameIdx + 1];\n            frame = keyframes[frameIdx];\n        }\n        if (!(frame && nextFrame)) {\n            return;\n        }\n        this._lastFr = frameIdx;\n        this._lastFrP = percent;\n        var interval = (nextFrame.percent - frame.percent);\n        var w = interval === 0 ? 1 : mathMin((percent - frame.percent) / interval, 1);\n        if (nextFrame.easingFunc) {\n            w = nextFrame.easingFunc(w);\n        }\n        var targetArr = isAdditive ? this._additiveValue\n            : (isValueColor ? tmpRgba : target[propName]);\n        if ((isArrayValueType(valType) || isValueColor) && !targetArr) {\n            targetArr = this._additiveValue = [];\n        }\n        if (this.discrete) {\n            target[propName] = w < 1 ? frame.rawValue : nextFrame.rawValue;\n        }\n        else if (isArrayValueType(valType)) {\n            valType === VALUE_TYPE_1D_ARRAY\n                ? interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w)\n                : interpolate2DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);\n        }\n        else if (isGradientValueType(valType)) {\n            var val = frame[valueKey];\n            var nextVal_1 = nextFrame[valueKey];\n            var isLinearGradient_1 = valType === VALUE_TYPE_LINEAR_GRADIENT;\n            target[propName] = {\n                type: isLinearGradient_1 ? 'linear' : 'radial',\n                x: interpolateNumber(val.x, nextVal_1.x, w),\n                y: interpolateNumber(val.y, nextVal_1.y, w),\n                colorStops: map(val.colorStops, function (colorStop, idx) {\n                    var nextColorStop = nextVal_1.colorStops[idx];\n                    return {\n                        offset: interpolateNumber(colorStop.offset, nextColorStop.offset, w),\n                        color: rgba2String(interpolate1DArray([], colorStop.color, nextColorStop.color, w))\n                    };\n                }),\n                global: nextVal_1.global\n            };\n            if (isLinearGradient_1) {\n                target[propName].x2 = interpolateNumber(val.x2, nextVal_1.x2, w);\n                target[propName].y2 = interpolateNumber(val.y2, nextVal_1.y2, w);\n            }\n            else {\n                target[propName].r = interpolateNumber(val.r, nextVal_1.r, w);\n            }\n        }\n        else if (isValueColor) {\n            interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);\n            if (!isAdditive) {\n                target[propName] = rgba2String(targetArr);\n            }\n        }\n        else {\n            var value = interpolateNumber(frame[valueKey], nextFrame[valueKey], w);\n            if (isAdditive) {\n                this._additiveValue = value;\n            }\n            else {\n                target[propName] = value;\n            }\n        }\n        if (isAdditive) {\n            this._addToTarget(target);\n        }\n    };\n    Track.prototype._addToTarget = function (target) {\n        var valType = this.valType;\n        var propName = this.propName;\n        var additiveValue = this._additiveValue;\n        if (valType === VALUE_TYPE_NUMBER) {\n            target[propName] = target[propName] + additiveValue;\n        }\n        else if (valType === VALUE_TYPE_COLOR) {\n            color.parse(target[propName], tmpRgba);\n            add1DArray(tmpRgba, tmpRgba, additiveValue, 1);\n            target[propName] = rgba2String(tmpRgba);\n        }\n        else if (valType === VALUE_TYPE_1D_ARRAY) {\n            add1DArray(target[propName], target[propName], additiveValue, 1);\n        }\n        else if (valType === VALUE_TYPE_2D_ARRAY) {\n            add2DArray(target[propName], target[propName], additiveValue, 1);\n        }\n    };\n    return Track;\n}());\nvar Animator = (function () {\n    function Animator(target, loop, allowDiscreteAnimation, additiveTo) {\n        this._tracks = {};\n        this._trackKeys = [];\n        this._maxTime = 0;\n        this._started = 0;\n        this._clip = null;\n        this._target = target;\n        this._loop = loop;\n        if (loop && additiveTo) {\n            logError('Can\\' use additive animation on looped animation.');\n            return;\n        }\n        this._additiveAnimators = additiveTo;\n        this._allowDiscrete = allowDiscreteAnimation;\n    }\n    Animator.prototype.getMaxTime = function () {\n        return this._maxTime;\n    };\n    Animator.prototype.getDelay = function () {\n        return this._delay;\n    };\n    Animator.prototype.getLoop = function () {\n        return this._loop;\n    };\n    Animator.prototype.getTarget = function () {\n        return this._target;\n    };\n    Animator.prototype.changeTarget = function (target) {\n        this._target = target;\n    };\n    Animator.prototype.when = function (time, props, easing) {\n        return this.whenWithKeys(time, props, keys(props), easing);\n    };\n    Animator.prototype.whenWithKeys = function (time, props, propNames, easing) {\n        var tracks = this._tracks;\n        for (var i = 0; i < propNames.length; i++) {\n            var propName = propNames[i];\n            var track = tracks[propName];\n            if (!track) {\n                track = tracks[propName] = new Track(propName);\n                var initialValue = void 0;\n                var additiveTrack = this._getAdditiveTrack(propName);\n                if (additiveTrack) {\n                    var addtiveTrackKfs = additiveTrack.keyframes;\n                    var lastFinalKf = addtiveTrackKfs[addtiveTrackKfs.length - 1];\n                    initialValue = lastFinalKf && lastFinalKf.value;\n                    if (additiveTrack.valType === VALUE_TYPE_COLOR && initialValue) {\n                        initialValue = rgba2String(initialValue);\n                    }\n                }\n                else {\n                    initialValue = this._target[propName];\n                }\n                if (initialValue == null) {\n                    continue;\n                }\n                if (time > 0) {\n                    track.addKeyframe(0, cloneValue(initialValue), easing);\n                }\n                this._trackKeys.push(propName);\n            }\n            track.addKeyframe(time, cloneValue(props[propName]), easing);\n        }\n        this._maxTime = Math.max(this._maxTime, time);\n        return this;\n    };\n    Animator.prototype.pause = function () {\n        this._clip.pause();\n        this._paused = true;\n    };\n    Animator.prototype.resume = function () {\n        this._clip.resume();\n        this._paused = false;\n    };\n    Animator.prototype.isPaused = function () {\n        return !!this._paused;\n    };\n    Animator.prototype.duration = function (duration) {\n        this._maxTime = duration;\n        this._force = true;\n        return this;\n    };\n    Animator.prototype._doneCallback = function () {\n        this._setTracksFinished();\n        this._clip = null;\n        var doneList = this._doneCbs;\n        if (doneList) {\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        }\n    };\n    Animator.prototype._abortedCallback = function () {\n        this._setTracksFinished();\n        var animation = this.animation;\n        var abortedList = this._abortedCbs;\n        if (animation) {\n            animation.removeClip(this._clip);\n        }\n        this._clip = null;\n        if (abortedList) {\n            for (var i = 0; i < abortedList.length; i++) {\n                abortedList[i].call(this);\n            }\n        }\n    };\n    Animator.prototype._setTracksFinished = function () {\n        var tracks = this._tracks;\n        var tracksKeys = this._trackKeys;\n        for (var i = 0; i < tracksKeys.length; i++) {\n            tracks[tracksKeys[i]].setFinished();\n        }\n    };\n    Animator.prototype._getAdditiveTrack = function (trackName) {\n        var additiveTrack;\n        var additiveAnimators = this._additiveAnimators;\n        if (additiveAnimators) {\n            for (var i = 0; i < additiveAnimators.length; i++) {\n                var track = additiveAnimators[i].getTrack(trackName);\n                if (track) {\n                    additiveTrack = track;\n                }\n            }\n        }\n        return additiveTrack;\n    };\n    Animator.prototype.start = function (easing) {\n        if (this._started > 0) {\n            return;\n        }\n        this._started = 1;\n        var self = this;\n        var tracks = [];\n        var maxTime = this._maxTime || 0;\n        for (var i = 0; i < this._trackKeys.length; i++) {\n            var propName = this._trackKeys[i];\n            var track = this._tracks[propName];\n            var additiveTrack = this._getAdditiveTrack(propName);\n            var kfs = track.keyframes;\n            var kfsNum = kfs.length;\n            track.prepare(maxTime, additiveTrack);\n            if (track.needsAnimate()) {\n                if (!this._allowDiscrete && track.discrete) {\n                    var lastKf = kfs[kfsNum - 1];\n                    if (lastKf) {\n                        self._target[track.propName] = lastKf.rawValue;\n                    }\n                    track.setFinished();\n                }\n                else {\n                    tracks.push(track);\n                }\n            }\n        }\n        if (tracks.length || this._force) {\n            var clip = new Clip({\n                life: maxTime,\n                loop: this._loop,\n                delay: this._delay || 0,\n                onframe: function (percent) {\n                    self._started = 2;\n                    var additiveAnimators = self._additiveAnimators;\n                    if (additiveAnimators) {\n                        var stillHasAdditiveAnimator = false;\n                        for (var i = 0; i < additiveAnimators.length; i++) {\n                            if (additiveAnimators[i]._clip) {\n                                stillHasAdditiveAnimator = true;\n                                break;\n                            }\n                        }\n                        if (!stillHasAdditiveAnimator) {\n                            self._additiveAnimators = null;\n                        }\n                    }\n                    for (var i = 0; i < tracks.length; i++) {\n                        tracks[i].step(self._target, percent);\n                    }\n                    var onframeList = self._onframeCbs;\n                    if (onframeList) {\n                        for (var i = 0; i < onframeList.length; i++) {\n                            onframeList[i](self._target, percent);\n                        }\n                    }\n                },\n                ondestroy: function () {\n                    self._doneCallback();\n                }\n            });\n            this._clip = clip;\n            if (this.animation) {\n                this.animation.addClip(clip);\n            }\n            if (easing) {\n                clip.setEasing(easing);\n            }\n        }\n        else {\n            this._doneCallback();\n        }\n        return this;\n    };\n    Animator.prototype.stop = function (forwardToLast) {\n        if (!this._clip) {\n            return;\n        }\n        var clip = this._clip;\n        if (forwardToLast) {\n            clip.onframe(1);\n        }\n        this._abortedCallback();\n    };\n    Animator.prototype.delay = function (time) {\n        this._delay = time;\n        return this;\n    };\n    Animator.prototype.during = function (cb) {\n        if (cb) {\n            if (!this._onframeCbs) {\n                this._onframeCbs = [];\n            }\n            this._onframeCbs.push(cb);\n        }\n        return this;\n    };\n    Animator.prototype.done = function (cb) {\n        if (cb) {\n            if (!this._doneCbs) {\n                this._doneCbs = [];\n            }\n            this._doneCbs.push(cb);\n        }\n        return this;\n    };\n    Animator.prototype.aborted = function (cb) {\n        if (cb) {\n            if (!this._abortedCbs) {\n                this._abortedCbs = [];\n            }\n            this._abortedCbs.push(cb);\n        }\n        return this;\n    };\n    Animator.prototype.getClip = function () {\n        return this._clip;\n    };\n    Animator.prototype.getTrack = function (propName) {\n        return this._tracks[propName];\n    };\n    Animator.prototype.getTracks = function () {\n        var _this = this;\n        return map(this._trackKeys, function (key) { return _this._tracks[key]; });\n    };\n    Animator.prototype.stopTracks = function (propNames, forwardToLast) {\n        if (!propNames.length || !this._clip) {\n            return true;\n        }\n        var tracks = this._tracks;\n        var tracksKeys = this._trackKeys;\n        for (var i = 0; i < propNames.length; i++) {\n            var track = tracks[propNames[i]];\n            if (track && !track.isFinished()) {\n                if (forwardToLast) {\n                    track.step(this._target, 1);\n                }\n                else if (this._started === 1) {\n                    track.step(this._target, 0);\n                }\n                track.setFinished();\n            }\n        }\n        var allAborted = true;\n        for (var i = 0; i < tracksKeys.length; i++) {\n            if (!tracks[tracksKeys[i]].isFinished()) {\n                allAborted = false;\n                break;\n            }\n        }\n        if (allAborted) {\n            this._abortedCallback();\n        }\n        return allAborted;\n    };\n    Animator.prototype.saveTo = function (target, trackKeys, firstOrLast) {\n        if (!target) {\n            return;\n        }\n        trackKeys = trackKeys || this._trackKeys;\n        for (var i = 0; i < trackKeys.length; i++) {\n            var propName = trackKeys[i];\n            var track = this._tracks[propName];\n            if (!track || track.isFinished()) {\n                continue;\n            }\n            var kfs = track.keyframes;\n            var kf = kfs[firstOrLast ? 0 : kfs.length - 1];\n            if (kf) {\n                target[propName] = cloneValue(kf.rawValue);\n            }\n        }\n    };\n    Animator.prototype.__changeFinalValue = function (finalProps, trackKeys) {\n        trackKeys = trackKeys || keys(finalProps);\n        for (var i = 0; i < trackKeys.length; i++) {\n            var propName = trackKeys[i];\n            var track = this._tracks[propName];\n            if (!track) {\n                continue;\n            }\n            var kfs = track.keyframes;\n            if (kfs.length > 1) {\n                var lastKf = kfs.pop();\n                track.addKeyframe(lastKf.time, finalProps[propName]);\n                track.prepare(this._maxTime, track.getAdditiveTrack());\n            }\n        }\n    };\n    return Animator;\n}());\nexport default Animator;\n"]},"metadata":{},"sourceType":"module"}