{"ast":null,"code":"import \"core-js/modules/es.function.name.js\";\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport { __extends } from \"tslib\";\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport * as vec2 from 'zrender/lib/core/vector.js';\nimport * as polygonContain from 'zrender/lib/contain/polygon.js';\nimport * as matrix from 'zrender/lib/core/matrix.js';\nimport { each } from 'zrender/lib/core/util.js';\nvar TMP_TRANSFORM = [];\n\nfunction transformPoints(points, transform) {\n  for (var p = 0; p < points.length; p++) {\n    vec2.applyTransform(points[p], points[p], transform);\n  }\n}\n\nfunction updateBBoxFromPoints(points, min, max, projection) {\n  for (var i = 0; i < points.length; i++) {\n    var p = points[i];\n\n    if (projection) {\n      // projection may return null point.\n      p = projection.project(p);\n    }\n\n    if (p && isFinite(p[0]) && isFinite(p[1])) {\n      vec2.min(min, min, p);\n      vec2.max(max, max, p);\n    }\n  }\n}\n\nfunction centroid(points) {\n  var signedArea = 0;\n  var cx = 0;\n  var cy = 0;\n  var len = points.length;\n  var x0 = points[len - 1][0];\n  var y0 = points[len - 1][1]; // Polygon should been closed.\n\n  for (var i = 0; i < len; i++) {\n    var x1 = points[i][0];\n    var y1 = points[i][1];\n    var a = x0 * y1 - x1 * y0;\n    signedArea += a;\n    cx += (x0 + x1) * a;\n    cy += (y0 + y1) * a;\n    x0 = x1;\n    y0 = y1;\n  }\n\n  return signedArea ? [cx / signedArea / 3, cy / signedArea / 3, signedArea] : [points[0][0] || 0, points[0][1] || 0];\n}\n\nvar Region =\n/** @class */\nfunction () {\n  function Region(name) {\n    this.name = name;\n  }\n\n  Region.prototype.setCenter = function (center) {\n    this._center = center;\n  };\n  /**\r\n   * Get center point in data unit. That is,\r\n   * for GeoJSONRegion, the unit is lat/lng,\r\n   * for GeoSVGRegion, the unit is SVG local coord.\r\n   */\n\n\n  Region.prototype.getCenter = function () {\n    var center = this._center;\n\n    if (!center) {\n      // In most cases there are no need to calculate this center.\n      // So calculate only when called.\n      center = this._center = this.calcCenter();\n    }\n\n    return center;\n  };\n\n  return Region;\n}();\n\nexport { Region };\n\nvar GeoJSONPolygonGeometry =\n/** @class */\nfunction () {\n  function GeoJSONPolygonGeometry(exterior, interiors) {\n    this.type = 'polygon';\n    this.exterior = exterior;\n    this.interiors = interiors;\n  }\n\n  return GeoJSONPolygonGeometry;\n}();\n\nexport { GeoJSONPolygonGeometry };\n\nvar GeoJSONLineStringGeometry =\n/** @class */\nfunction () {\n  function GeoJSONLineStringGeometry(points) {\n    this.type = 'linestring';\n    this.points = points;\n  }\n\n  return GeoJSONLineStringGeometry;\n}();\n\nexport { GeoJSONLineStringGeometry };\n\nvar GeoJSONRegion =\n/** @class */\nfunction (_super) {\n  __extends(GeoJSONRegion, _super);\n\n  function GeoJSONRegion(name, geometries, cp) {\n    var _this = _super.call(this, name) || this;\n\n    _this.type = 'geoJSON';\n    _this.geometries = geometries;\n    _this._center = cp && [cp[0], cp[1]];\n    return _this;\n  }\n\n  GeoJSONRegion.prototype.calcCenter = function () {\n    var geometries = this.geometries;\n    var largestGeo;\n    var largestGeoSize = 0;\n\n    for (var i = 0; i < geometries.length; i++) {\n      var geo = geometries[i];\n      var exterior = geo.exterior; // Simple trick to use points count instead of polygon area as region size.\n      // Ignore linestring\n\n      var size = exterior && exterior.length;\n\n      if (size > largestGeoSize) {\n        largestGeo = geo;\n        largestGeoSize = size;\n      }\n    }\n\n    if (largestGeo) {\n      return centroid(largestGeo.exterior);\n    } // from bounding rect by default.\n\n\n    var rect = this.getBoundingRect();\n    return [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  };\n\n  GeoJSONRegion.prototype.getBoundingRect = function (projection) {\n    var rect = this._rect; // Always recalculate if using projection.\n\n    if (rect && !projection) {\n      return rect;\n    }\n\n    var min = [Infinity, Infinity];\n    var max = [-Infinity, -Infinity];\n    var geometries = this.geometries;\n    each(geometries, function (geo) {\n      if (geo.type === 'polygon') {\n        // Doesn't consider hole\n        updateBBoxFromPoints(geo.exterior, min, max, projection);\n      } else {\n        each(geo.points, function (points) {\n          updateBBoxFromPoints(points, min, max, projection);\n        });\n      }\n    }); // Normalie invalid bounding.\n\n    if (!(isFinite(min[0]) && isFinite(min[1]) && isFinite(max[0]) && isFinite(max[1]))) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n\n    rect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\n    if (!projection) {\n      this._rect = rect;\n    }\n\n    return rect;\n  };\n\n  GeoJSONRegion.prototype.contain = function (coord) {\n    var rect = this.getBoundingRect();\n    var geometries = this.geometries;\n\n    if (!rect.contain(coord[0], coord[1])) {\n      return false;\n    }\n\n    loopGeo: for (var i = 0, len = geometries.length; i < len; i++) {\n      var geo = geometries[i]; // Only support polygon.\n\n      if (geo.type !== 'polygon') {\n        continue;\n      }\n\n      var exterior = geo.exterior;\n      var interiors = geo.interiors;\n\n      if (polygonContain.contain(exterior, coord[0], coord[1])) {\n        // Not in the region if point is in the hole.\n        for (var k = 0; k < (interiors ? interiors.length : 0); k++) {\n          if (polygonContain.contain(interiors[k], coord[0], coord[1])) {\n            continue loopGeo;\n          }\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * Transform the raw coords to target bounding.\r\n   * @param x\r\n   * @param y\r\n   * @param width\r\n   * @param height\r\n   */\n\n\n  GeoJSONRegion.prototype.transformTo = function (x, y, width, height) {\n    var rect = this.getBoundingRect();\n    var aspect = rect.width / rect.height;\n\n    if (!width) {\n      width = aspect * height;\n    } else if (!height) {\n      height = width / aspect;\n    }\n\n    var target = new BoundingRect(x, y, width, height);\n    var transform = rect.calculateTransform(target);\n    var geometries = this.geometries;\n\n    for (var i = 0; i < geometries.length; i++) {\n      var geo = geometries[i];\n\n      if (geo.type === 'polygon') {\n        transformPoints(geo.exterior, transform);\n        each(geo.interiors, function (interior) {\n          transformPoints(interior, transform);\n        });\n      } else {\n        each(geo.points, function (points) {\n          transformPoints(points, transform);\n        });\n      }\n    }\n\n    rect = this._rect;\n    rect.copy(target); // Update center\n\n    this._center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  };\n\n  GeoJSONRegion.prototype.cloneShallow = function (name) {\n    name == null && (name = this.name);\n    var newRegion = new GeoJSONRegion(name, this.geometries, this._center);\n    newRegion._rect = this._rect;\n    newRegion.transformTo = null; // Simply avoid to be called.\n\n    return newRegion;\n  };\n\n  return GeoJSONRegion;\n}(Region);\n\nexport { GeoJSONRegion };\n\nvar GeoSVGRegion =\n/** @class */\nfunction (_super) {\n  __extends(GeoSVGRegion, _super);\n\n  function GeoSVGRegion(name, elOnlyForCalculate) {\n    var _this = _super.call(this, name) || this;\n\n    _this.type = 'geoSVG';\n    _this._elOnlyForCalculate = elOnlyForCalculate;\n    return _this;\n  }\n\n  GeoSVGRegion.prototype.calcCenter = function () {\n    var el = this._elOnlyForCalculate;\n    var rect = el.getBoundingRect();\n    var center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n    var mat = matrix.identity(TMP_TRANSFORM);\n    var target = el;\n\n    while (target && !target.isGeoSVGGraphicRoot) {\n      matrix.mul(mat, target.getLocalTransform(), mat);\n      target = target.parent;\n    }\n\n    matrix.invert(mat, mat);\n    vec2.applyTransform(center, center, mat);\n    return center;\n  };\n\n  return GeoSVGRegion;\n}(Region);\n\nexport { GeoSVGRegion };","map":{"version":3,"sources":["F:/Desktop/繁星教育/TH资料/two_hours_front/node_modules/echarts/lib/coord/geo/Region.js"],"names":["__extends","BoundingRect","vec2","polygonContain","matrix","each","TMP_TRANSFORM","transformPoints","points","transform","p","length","applyTransform","updateBBoxFromPoints","min","max","projection","i","project","isFinite","centroid","signedArea","cx","cy","len","x0","y0","x1","y1","a","Region","name","prototype","setCenter","center","_center","getCenter","calcCenter","GeoJSONPolygonGeometry","exterior","interiors","type","GeoJSONLineStringGeometry","GeoJSONRegion","_super","geometries","cp","_this","call","largestGeo","largestGeoSize","geo","size","rect","getBoundingRect","x","width","y","height","_rect","Infinity","contain","coord","loopGeo","k","transformTo","aspect","target","calculateTransform","interior","copy","cloneShallow","newRegion","GeoSVGRegion","elOnlyForCalculate","_elOnlyForCalculate","el","mat","identity","isGeoSVGGraphicRoot","mul","getLocalTransform","parent","invert"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport { __extends } from \"tslib\";\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport * as vec2 from 'zrender/lib/core/vector.js';\nimport * as polygonContain from 'zrender/lib/contain/polygon.js';\nimport * as matrix from 'zrender/lib/core/matrix.js';\nimport { each } from 'zrender/lib/core/util.js';\nvar TMP_TRANSFORM = [];\n\nfunction transformPoints(points, transform) {\n  for (var p = 0; p < points.length; p++) {\n    vec2.applyTransform(points[p], points[p], transform);\n  }\n}\n\nfunction updateBBoxFromPoints(points, min, max, projection) {\n  for (var i = 0; i < points.length; i++) {\n    var p = points[i];\n\n    if (projection) {\n      // projection may return null point.\n      p = projection.project(p);\n    }\n\n    if (p && isFinite(p[0]) && isFinite(p[1])) {\n      vec2.min(min, min, p);\n      vec2.max(max, max, p);\n    }\n  }\n}\n\nfunction centroid(points) {\n  var signedArea = 0;\n  var cx = 0;\n  var cy = 0;\n  var len = points.length;\n  var x0 = points[len - 1][0];\n  var y0 = points[len - 1][1]; // Polygon should been closed.\n\n  for (var i = 0; i < len; i++) {\n    var x1 = points[i][0];\n    var y1 = points[i][1];\n    var a = x0 * y1 - x1 * y0;\n    signedArea += a;\n    cx += (x0 + x1) * a;\n    cy += (y0 + y1) * a;\n    x0 = x1;\n    y0 = y1;\n  }\n\n  return signedArea ? [cx / signedArea / 3, cy / signedArea / 3, signedArea] : [points[0][0] || 0, points[0][1] || 0];\n}\n\nvar Region =\n/** @class */\nfunction () {\n  function Region(name) {\n    this.name = name;\n  }\n\n  Region.prototype.setCenter = function (center) {\n    this._center = center;\n  };\n  /**\r\n   * Get center point in data unit. That is,\r\n   * for GeoJSONRegion, the unit is lat/lng,\r\n   * for GeoSVGRegion, the unit is SVG local coord.\r\n   */\n\n\n  Region.prototype.getCenter = function () {\n    var center = this._center;\n\n    if (!center) {\n      // In most cases there are no need to calculate this center.\n      // So calculate only when called.\n      center = this._center = this.calcCenter();\n    }\n\n    return center;\n  };\n\n  return Region;\n}();\n\nexport { Region };\n\nvar GeoJSONPolygonGeometry =\n/** @class */\nfunction () {\n  function GeoJSONPolygonGeometry(exterior, interiors) {\n    this.type = 'polygon';\n    this.exterior = exterior;\n    this.interiors = interiors;\n  }\n\n  return GeoJSONPolygonGeometry;\n}();\n\nexport { GeoJSONPolygonGeometry };\n\nvar GeoJSONLineStringGeometry =\n/** @class */\nfunction () {\n  function GeoJSONLineStringGeometry(points) {\n    this.type = 'linestring';\n    this.points = points;\n  }\n\n  return GeoJSONLineStringGeometry;\n}();\n\nexport { GeoJSONLineStringGeometry };\n\nvar GeoJSONRegion =\n/** @class */\nfunction (_super) {\n  __extends(GeoJSONRegion, _super);\n\n  function GeoJSONRegion(name, geometries, cp) {\n    var _this = _super.call(this, name) || this;\n\n    _this.type = 'geoJSON';\n    _this.geometries = geometries;\n    _this._center = cp && [cp[0], cp[1]];\n    return _this;\n  }\n\n  GeoJSONRegion.prototype.calcCenter = function () {\n    var geometries = this.geometries;\n    var largestGeo;\n    var largestGeoSize = 0;\n\n    for (var i = 0; i < geometries.length; i++) {\n      var geo = geometries[i];\n      var exterior = geo.exterior; // Simple trick to use points count instead of polygon area as region size.\n      // Ignore linestring\n\n      var size = exterior && exterior.length;\n\n      if (size > largestGeoSize) {\n        largestGeo = geo;\n        largestGeoSize = size;\n      }\n    }\n\n    if (largestGeo) {\n      return centroid(largestGeo.exterior);\n    } // from bounding rect by default.\n\n\n    var rect = this.getBoundingRect();\n    return [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  };\n\n  GeoJSONRegion.prototype.getBoundingRect = function (projection) {\n    var rect = this._rect; // Always recalculate if using projection.\n\n    if (rect && !projection) {\n      return rect;\n    }\n\n    var min = [Infinity, Infinity];\n    var max = [-Infinity, -Infinity];\n    var geometries = this.geometries;\n    each(geometries, function (geo) {\n      if (geo.type === 'polygon') {\n        // Doesn't consider hole\n        updateBBoxFromPoints(geo.exterior, min, max, projection);\n      } else {\n        each(geo.points, function (points) {\n          updateBBoxFromPoints(points, min, max, projection);\n        });\n      }\n    }); // Normalie invalid bounding.\n\n    if (!(isFinite(min[0]) && isFinite(min[1]) && isFinite(max[0]) && isFinite(max[1]))) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n\n    rect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\n    if (!projection) {\n      this._rect = rect;\n    }\n\n    return rect;\n  };\n\n  GeoJSONRegion.prototype.contain = function (coord) {\n    var rect = this.getBoundingRect();\n    var geometries = this.geometries;\n\n    if (!rect.contain(coord[0], coord[1])) {\n      return false;\n    }\n\n    loopGeo: for (var i = 0, len = geometries.length; i < len; i++) {\n      var geo = geometries[i]; // Only support polygon.\n\n      if (geo.type !== 'polygon') {\n        continue;\n      }\n\n      var exterior = geo.exterior;\n      var interiors = geo.interiors;\n\n      if (polygonContain.contain(exterior, coord[0], coord[1])) {\n        // Not in the region if point is in the hole.\n        for (var k = 0; k < (interiors ? interiors.length : 0); k++) {\n          if (polygonContain.contain(interiors[k], coord[0], coord[1])) {\n            continue loopGeo;\n          }\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * Transform the raw coords to target bounding.\r\n   * @param x\r\n   * @param y\r\n   * @param width\r\n   * @param height\r\n   */\n\n\n  GeoJSONRegion.prototype.transformTo = function (x, y, width, height) {\n    var rect = this.getBoundingRect();\n    var aspect = rect.width / rect.height;\n\n    if (!width) {\n      width = aspect * height;\n    } else if (!height) {\n      height = width / aspect;\n    }\n\n    var target = new BoundingRect(x, y, width, height);\n    var transform = rect.calculateTransform(target);\n    var geometries = this.geometries;\n\n    for (var i = 0; i < geometries.length; i++) {\n      var geo = geometries[i];\n\n      if (geo.type === 'polygon') {\n        transformPoints(geo.exterior, transform);\n        each(geo.interiors, function (interior) {\n          transformPoints(interior, transform);\n        });\n      } else {\n        each(geo.points, function (points) {\n          transformPoints(points, transform);\n        });\n      }\n    }\n\n    rect = this._rect;\n    rect.copy(target); // Update center\n\n    this._center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  };\n\n  GeoJSONRegion.prototype.cloneShallow = function (name) {\n    name == null && (name = this.name);\n    var newRegion = new GeoJSONRegion(name, this.geometries, this._center);\n    newRegion._rect = this._rect;\n    newRegion.transformTo = null; // Simply avoid to be called.\n\n    return newRegion;\n  };\n\n  return GeoJSONRegion;\n}(Region);\n\nexport { GeoJSONRegion };\n\nvar GeoSVGRegion =\n/** @class */\nfunction (_super) {\n  __extends(GeoSVGRegion, _super);\n\n  function GeoSVGRegion(name, elOnlyForCalculate) {\n    var _this = _super.call(this, name) || this;\n\n    _this.type = 'geoSVG';\n    _this._elOnlyForCalculate = elOnlyForCalculate;\n    return _this;\n  }\n\n  GeoSVGRegion.prototype.calcCenter = function () {\n    var el = this._elOnlyForCalculate;\n    var rect = el.getBoundingRect();\n    var center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n    var mat = matrix.identity(TMP_TRANSFORM);\n    var target = el;\n\n    while (target && !target.isGeoSVGGraphicRoot) {\n      matrix.mul(mat, target.getLocalTransform(), mat);\n      target = target.parent;\n    }\n\n    matrix.invert(mat, mat);\n    vec2.applyTransform(center, center, mat);\n    return center;\n  };\n\n  return GeoSVGRegion;\n}(Region);\n\nexport { GeoSVGRegion };"]},"metadata":{},"sourceType":"module"}